"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-dropzone";
exports.ids = ["vendor-chunks/react-dropzone"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-dropzone/dist/es/index.js":
/*!******************************************************!*\
  !*** ./node_modules/react-dropzone/dist/es/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ErrorCode: () => (/* reexport safe */ _utils_index__WEBPACK_IMPORTED_MODULE_3__.ErrorCode),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   useDropzone: () => (/* binding */ useDropzone)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prop-types */ \"(ssr)/./node_modules/prop-types/index.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var file_selector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! file-selector */ \"(ssr)/./node_modules/file-selector/dist/es2015/index.js\");\n/* harmony import */ var _utils_index__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/react-dropzone/dist/es/utils/index.js\");\nvar _excluded = [\n    \"children\"\n], _excluded2 = [\n    \"open\"\n], _excluded3 = [\n    \"refKey\",\n    \"role\",\n    \"onKeyDown\",\n    \"onFocus\",\n    \"onBlur\",\n    \"onClick\",\n    \"onDragEnter\",\n    \"onDragOver\",\n    \"onDragLeave\",\n    \"onDrop\"\n], _excluded4 = [\n    \"refKey\",\n    \"onChange\",\n    \"onClick\"\n];\nfunction _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++){\n        arr2[i] = arr[i];\n    }\n    return arr2;\n}\nfunction _iterableToArrayLimit(arr, i) {\n    var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n    if (_i == null) return;\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _s, _e;\n    try {\n        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){\n            _arr.push(_s.value);\n            if (i && _arr.length === i) break;\n        }\n    } catch (err) {\n        _d = true;\n        _e = err;\n    } finally{\n        try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n        } finally{\n            if (_d) throw _e;\n        }\n    }\n    return _arr;\n}\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        enumerableOnly && (symbols = symbols.filter(function(sym) {\n            return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n        })), keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = null != arguments[i] ? arguments[i] : {};\n        i % 2 ? ownKeys(Object(source), !0).forEach(function(key) {\n            _defineProperty(target, key, source[key]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n    }\n    return target;\n}\nfunction _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n    for(i = 0; i < sourceKeys.length; i++){\n        key = sourceKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        target[key] = source[key];\n    }\n    return target;\n}\n/* eslint prefer-template: 0 */ \n\n\n\n/**\n * Convenience wrapper component for the `useDropzone` hook\n *\n * ```jsx\n * <Dropzone>\n *   {({getRootProps, getInputProps}) => (\n *     <div {...getRootProps()}>\n *       <input {...getInputProps()} />\n *       <p>Drag 'n' drop some files here, or click to select files</p>\n *     </div>\n *   )}\n * </Dropzone>\n * ```\n */ var Dropzone = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function(_ref, ref) {\n    var children = _ref.children, params = _objectWithoutProperties(_ref, _excluded);\n    var _useDropzone = useDropzone(params), open = _useDropzone.open, props = _objectWithoutProperties(_useDropzone, _excluded2);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, function() {\n        return {\n            open: open\n        };\n    }, [\n        open\n    ]); // TODO: Figure out why react-styleguidist cannot create docs if we don't return a jsx element\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, children(_objectSpread(_objectSpread({}, props), {}, {\n        open: open\n    })));\n});\nDropzone.displayName = \"Dropzone\"; // Add default props for react-docgen\nvar defaultProps = {\n    disabled: false,\n    getFilesFromEvent: file_selector__WEBPACK_IMPORTED_MODULE_1__.fromEvent,\n    maxSize: Infinity,\n    minSize: 0,\n    multiple: true,\n    maxFiles: 0,\n    preventDropOnDocument: true,\n    noClick: false,\n    noKeyboard: false,\n    noDrag: false,\n    noDragEventsBubbling: false,\n    validator: null,\n    useFsAccessApi: false,\n    autoFocus: false\n};\nDropzone.defaultProps = defaultProps;\nDropzone.propTypes = {\n    /**\n   * Render function that exposes the dropzone state and prop getter fns\n   *\n   * @param {object} params\n   * @param {Function} params.getRootProps Returns the props you should apply to the root drop container you render\n   * @param {Function} params.getInputProps Returns the props you should apply to hidden file input you render\n   * @param {Function} params.open Open the native file selection dialog\n   * @param {boolean} params.isFocused Dropzone area is in focus\n   * @param {boolean} params.isFileDialogActive File dialog is opened\n   * @param {boolean} params.isDragActive Active drag is in progress\n   * @param {boolean} params.isDragAccept Dragged files are accepted\n   * @param {boolean} params.isDragReject Some dragged files are rejected\n   * @param {File[]} params.acceptedFiles Accepted files\n   * @param {FileRejection[]} params.fileRejections Rejected files and why they were rejected\n   */ children: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().func),\n    /**\n   * Set accepted file types.\n   * Checkout https://developer.mozilla.org/en-US/docs/Web/API/window/showOpenFilePicker types option for more information.\n   * Keep in mind that mime type determination is not reliable across platforms. CSV files,\n   * for example, are reported as text/plain under macOS but as application/vnd.ms-excel under\n   * Windows. In some cases there might not be a mime type set at all (https://github.com/react-dropzone/react-dropzone/issues/276).\n   */ accept: prop_types__WEBPACK_IMPORTED_MODULE_2___default().objectOf(prop_types__WEBPACK_IMPORTED_MODULE_2___default().arrayOf((prop_types__WEBPACK_IMPORTED_MODULE_2___default().string))),\n    /**\n   * Allow drag 'n' drop (or selection from the file dialog) of multiple files\n   */ multiple: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().bool),\n    /**\n   * If false, allow dropped items to take over the current browser window\n   */ preventDropOnDocument: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().bool),\n    /**\n   * If true, disables click to open the native file selection dialog\n   */ noClick: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().bool),\n    /**\n   * If true, disables SPACE/ENTER to open the native file selection dialog.\n   * Note that it also stops tracking the focus state.\n   */ noKeyboard: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().bool),\n    /**\n   * If true, disables drag 'n' drop\n   */ noDrag: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().bool),\n    /**\n   * If true, stops drag event propagation to parents\n   */ noDragEventsBubbling: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().bool),\n    /**\n   * Minimum file size (in bytes)\n   */ minSize: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().number),\n    /**\n   * Maximum file size (in bytes)\n   */ maxSize: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().number),\n    /**\n   * Maximum accepted number of files\n   * The default value is 0 which means there is no limitation to how many files are accepted.\n   */ maxFiles: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().number),\n    /**\n   * Enable/disable the dropzone\n   */ disabled: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().bool),\n    /**\n   * Use this to provide a custom file aggregator\n   *\n   * @param {(DragEvent|Event)} event A drag event or input change event (if files were selected via the file dialog)\n   */ getFilesFromEvent: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().func),\n    /**\n   * Cb for when closing the file dialog with no selection\n   */ onFileDialogCancel: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().func),\n    /**\n   * Cb for when opening the file dialog\n   */ onFileDialogOpen: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().func),\n    /**\n   * Set to true to use the https://developer.mozilla.org/en-US/docs/Web/API/File_System_Access_API\n   * to open the file picker instead of using an `<input type=\"file\">` click event.\n   */ useFsAccessApi: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().bool),\n    /**\n   * Set to true to focus the root element on render\n   */ autoFocus: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().bool),\n    /**\n   * Cb for when the `dragenter` event occurs.\n   *\n   * @param {DragEvent} event\n   */ onDragEnter: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().func),\n    /**\n   * Cb for when the `dragleave` event occurs\n   *\n   * @param {DragEvent} event\n   */ onDragLeave: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().func),\n    /**\n   * Cb for when the `dragover` event occurs\n   *\n   * @param {DragEvent} event\n   */ onDragOver: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().func),\n    /**\n   * Cb for when the `drop` event occurs.\n   * Note that this callback is invoked after the `getFilesFromEvent` callback is done.\n   *\n   * Files are accepted or rejected based on the `accept`, `multiple`, `minSize` and `maxSize` props.\n   * `accept` must be a valid [MIME type](http://www.iana.org/assignments/media-types/media-types.xhtml) according to [input element specification](https://www.w3.org/wiki/HTML/Elements/input/file) or a valid file extension.\n   * If `multiple` is set to false and additional files are dropped,\n   * all files besides the first will be rejected.\n   * Any file which does not have a size in the [`minSize`, `maxSize`] range, will be rejected as well.\n   *\n   * Note that the `onDrop` callback will always be invoked regardless if the dropped files were accepted or rejected.\n   * If you'd like to react to a specific scenario, use the `onDropAccepted`/`onDropRejected` props.\n   *\n   * `onDrop` will provide you with an array of [File](https://developer.mozilla.org/en-US/docs/Web/API/File) objects which you can then process and send to a server.\n   * For example, with [SuperAgent](https://github.com/visionmedia/superagent) as a http/ajax library:\n   *\n   * ```js\n   * function onDrop(acceptedFiles) {\n   *   const req = request.post('/upload')\n   *   acceptedFiles.forEach(file => {\n   *     req.attach(file.name, file)\n   *   })\n   *   req.end(callback)\n   * }\n   * ```\n   *\n   * @param {File[]} acceptedFiles\n   * @param {FileRejection[]} fileRejections\n   * @param {(DragEvent|Event)} event A drag event or input change event (if files were selected via the file dialog)\n   */ onDrop: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().func),\n    /**\n   * Cb for when the `drop` event occurs.\n   * Note that if no files are accepted, this callback is not invoked.\n   *\n   * @param {File[]} files\n   * @param {(DragEvent|Event)} event\n   */ onDropAccepted: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().func),\n    /**\n   * Cb for when the `drop` event occurs.\n   * Note that if no files are rejected, this callback is not invoked.\n   *\n   * @param {FileRejection[]} fileRejections\n   * @param {(DragEvent|Event)} event\n   */ onDropRejected: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().func),\n    /**\n   * Cb for when there's some error from any of the promises.\n   *\n   * @param {Error} error\n   */ onError: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().func),\n    /**\n   * Custom validation function. It must return null if there's no errors.\n   * @param {File} file\n   * @returns {FileError|FileError[]|null}\n   */ validator: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().func)\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Dropzone);\n/**\n * A function that is invoked for the `dragenter`,\n * `dragover` and `dragleave` events.\n * It is not invoked if the items are not files (such as link, text, etc.).\n *\n * @callback dragCb\n * @param {DragEvent} event\n */ /**\n * A function that is invoked for the `drop` or input change event.\n * It is not invoked if the items are not files (such as link, text, etc.).\n *\n * @callback dropCb\n * @param {File[]} acceptedFiles List of accepted files\n * @param {FileRejection[]} fileRejections List of rejected files and why they were rejected\n * @param {(DragEvent|Event)} event A drag event or input change event (if files were selected via the file dialog)\n */ /**\n * A function that is invoked for the `drop` or input change event.\n * It is not invoked if the items are files (such as link, text, etc.).\n *\n * @callback dropAcceptedCb\n * @param {File[]} files List of accepted files that meet the given criteria\n * (`accept`, `multiple`, `minSize`, `maxSize`)\n * @param {(DragEvent|Event)} event A drag event or input change event (if files were selected via the file dialog)\n */ /**\n * A function that is invoked for the `drop` or input change event.\n *\n * @callback dropRejectedCb\n * @param {File[]} files List of rejected files that do not meet the given criteria\n * (`accept`, `multiple`, `minSize`, `maxSize`)\n * @param {(DragEvent|Event)} event A drag event or input change event (if files were selected via the file dialog)\n */ /**\n * A function that is used aggregate files,\n * in a asynchronous fashion, from drag or input change events.\n *\n * @callback getFilesFromEvent\n * @param {(DragEvent|Event)} event A drag event or input change event (if files were selected via the file dialog)\n * @returns {(File[]|Promise<File[]>)}\n */ /**\n * An object with the current dropzone state.\n *\n * @typedef {object} DropzoneState\n * @property {boolean} isFocused Dropzone area is in focus\n * @property {boolean} isFileDialogActive File dialog is opened\n * @property {boolean} isDragActive Active drag is in progress\n * @property {boolean} isDragAccept Dragged files are accepted\n * @property {boolean} isDragReject Some dragged files are rejected\n * @property {File[]} acceptedFiles Accepted files\n * @property {FileRejection[]} fileRejections Rejected files and why they were rejected\n */ /**\n * An object with the dropzone methods.\n *\n * @typedef {object} DropzoneMethods\n * @property {Function} getRootProps Returns the props you should apply to the root drop container you render\n * @property {Function} getInputProps Returns the props you should apply to hidden file input you render\n * @property {Function} open Open the native file selection dialog\n */ var initialState = {\n    isFocused: false,\n    isFileDialogActive: false,\n    isDragActive: false,\n    isDragAccept: false,\n    isDragReject: false,\n    acceptedFiles: [],\n    fileRejections: []\n};\n/**\n * A React hook that creates a drag 'n' drop area.\n *\n * ```jsx\n * function MyDropzone(props) {\n *   const {getRootProps, getInputProps} = useDropzone({\n *     onDrop: acceptedFiles => {\n *       // do something with the File objects, e.g. upload to some server\n *     }\n *   });\n *   return (\n *     <div {...getRootProps()}>\n *       <input {...getInputProps()} />\n *       <p>Drag and drop some files here, or click to select files</p>\n *     </div>\n *   )\n * }\n * ```\n *\n * @function useDropzone\n *\n * @param {object} props\n * @param {import(\"./utils\").AcceptProp} [props.accept] Set accepted file types.\n * Checkout https://developer.mozilla.org/en-US/docs/Web/API/window/showOpenFilePicker types option for more information.\n * Keep in mind that mime type determination is not reliable across platforms. CSV files,\n * for example, are reported as text/plain under macOS but as application/vnd.ms-excel under\n * Windows. In some cases there might not be a mime type set at all (https://github.com/react-dropzone/react-dropzone/issues/276).\n * @param {boolean} [props.multiple=true] Allow drag 'n' drop (or selection from the file dialog) of multiple files\n * @param {boolean} [props.preventDropOnDocument=true] If false, allow dropped items to take over the current browser window\n * @param {boolean} [props.noClick=false] If true, disables click to open the native file selection dialog\n * @param {boolean} [props.noKeyboard=false] If true, disables SPACE/ENTER to open the native file selection dialog.\n * Note that it also stops tracking the focus state.\n * @param {boolean} [props.noDrag=false] If true, disables drag 'n' drop\n * @param {boolean} [props.noDragEventsBubbling=false] If true, stops drag event propagation to parents\n * @param {number} [props.minSize=0] Minimum file size (in bytes)\n * @param {number} [props.maxSize=Infinity] Maximum file size (in bytes)\n * @param {boolean} [props.disabled=false] Enable/disable the dropzone\n * @param {getFilesFromEvent} [props.getFilesFromEvent] Use this to provide a custom file aggregator\n * @param {Function} [props.onFileDialogCancel] Cb for when closing the file dialog with no selection\n * @param {boolean} [props.useFsAccessApi] Set to true to use the https://developer.mozilla.org/en-US/docs/Web/API/File_System_Access_API\n * to open the file picker instead of using an `<input type=\"file\">` click event.\n * @param {boolean} autoFocus Set to true to auto focus the root element.\n * @param {Function} [props.onFileDialogOpen] Cb for when opening the file dialog\n * @param {dragCb} [props.onDragEnter] Cb for when the `dragenter` event occurs.\n * @param {dragCb} [props.onDragLeave] Cb for when the `dragleave` event occurs\n * @param {dragCb} [props.onDragOver] Cb for when the `dragover` event occurs\n * @param {dropCb} [props.onDrop] Cb for when the `drop` event occurs.\n * Note that this callback is invoked after the `getFilesFromEvent` callback is done.\n *\n * Files are accepted or rejected based on the `accept`, `multiple`, `minSize` and `maxSize` props.\n * `accept` must be an object with keys as a valid [MIME type](http://www.iana.org/assignments/media-types/media-types.xhtml) according to [input element specification](https://www.w3.org/wiki/HTML/Elements/input/file) and the value an array of file extensions (optional).\n * If `multiple` is set to false and additional files are dropped,\n * all files besides the first will be rejected.\n * Any file which does not have a size in the [`minSize`, `maxSize`] range, will be rejected as well.\n *\n * Note that the `onDrop` callback will always be invoked regardless if the dropped files were accepted or rejected.\n * If you'd like to react to a specific scenario, use the `onDropAccepted`/`onDropRejected` props.\n *\n * `onDrop` will provide you with an array of [File](https://developer.mozilla.org/en-US/docs/Web/API/File) objects which you can then process and send to a server.\n * For example, with [SuperAgent](https://github.com/visionmedia/superagent) as a http/ajax library:\n *\n * ```js\n * function onDrop(acceptedFiles) {\n *   const req = request.post('/upload')\n *   acceptedFiles.forEach(file => {\n *     req.attach(file.name, file)\n *   })\n *   req.end(callback)\n * }\n * ```\n * @param {dropAcceptedCb} [props.onDropAccepted]\n * @param {dropRejectedCb} [props.onDropRejected]\n * @param {(error: Error) => void} [props.onError]\n *\n * @returns {DropzoneState & DropzoneMethods}\n */ function useDropzone() {\n    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var _defaultProps$props = _objectSpread(_objectSpread({}, defaultProps), props), accept = _defaultProps$props.accept, disabled = _defaultProps$props.disabled, getFilesFromEvent = _defaultProps$props.getFilesFromEvent, maxSize = _defaultProps$props.maxSize, minSize = _defaultProps$props.minSize, multiple = _defaultProps$props.multiple, maxFiles = _defaultProps$props.maxFiles, onDragEnter = _defaultProps$props.onDragEnter, onDragLeave = _defaultProps$props.onDragLeave, onDragOver = _defaultProps$props.onDragOver, onDrop = _defaultProps$props.onDrop, onDropAccepted = _defaultProps$props.onDropAccepted, onDropRejected = _defaultProps$props.onDropRejected, onFileDialogCancel = _defaultProps$props.onFileDialogCancel, onFileDialogOpen = _defaultProps$props.onFileDialogOpen, useFsAccessApi = _defaultProps$props.useFsAccessApi, autoFocus = _defaultProps$props.autoFocus, preventDropOnDocument = _defaultProps$props.preventDropOnDocument, noClick = _defaultProps$props.noClick, noKeyboard = _defaultProps$props.noKeyboard, noDrag = _defaultProps$props.noDrag, noDragEventsBubbling = _defaultProps$props.noDragEventsBubbling, onError = _defaultProps$props.onError, validator = _defaultProps$props.validator;\n    var acceptAttr = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(function() {\n        return (0,_utils_index__WEBPACK_IMPORTED_MODULE_3__.acceptPropAsAcceptAttr)(accept);\n    }, [\n        accept\n    ]);\n    var pickerTypes = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(function() {\n        return (0,_utils_index__WEBPACK_IMPORTED_MODULE_3__.pickerOptionsFromAccept)(accept);\n    }, [\n        accept\n    ]);\n    var onFileDialogOpenCb = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(function() {\n        return typeof onFileDialogOpen === \"function\" ? onFileDialogOpen : noop;\n    }, [\n        onFileDialogOpen\n    ]);\n    var onFileDialogCancelCb = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(function() {\n        return typeof onFileDialogCancel === \"function\" ? onFileDialogCancel : noop;\n    }, [\n        onFileDialogCancel\n    ]);\n    /**\n   * @constant\n   * @type {React.MutableRefObject<HTMLElement>}\n   */ var rootRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    var inputRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    var _useReducer = (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)(reducer, initialState), _useReducer2 = _slicedToArray(_useReducer, 2), state = _useReducer2[0], dispatch = _useReducer2[1];\n    var isFocused = state.isFocused, isFileDialogActive = state.isFileDialogActive;\n    var fsAccessApiWorksRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)( false && 0); // Update file dialog active state when the window is focused on\n    var onWindowFocus = function onWindowFocus() {\n        // Execute the timeout only if the file dialog is opened in the browser\n        if (!fsAccessApiWorksRef.current && isFileDialogActive) {\n            setTimeout(function() {\n                if (inputRef.current) {\n                    var files = inputRef.current.files;\n                    if (!files.length) {\n                        dispatch({\n                            type: \"closeDialog\"\n                        });\n                        onFileDialogCancelCb();\n                    }\n                }\n            }, 300);\n        }\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function() {\n        window.addEventListener(\"focus\", onWindowFocus, false);\n        return function() {\n            window.removeEventListener(\"focus\", onWindowFocus, false);\n        };\n    }, [\n        inputRef,\n        isFileDialogActive,\n        onFileDialogCancelCb,\n        fsAccessApiWorksRef\n    ]);\n    var dragTargetsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    var onDocumentDrop = function onDocumentDrop(event) {\n        if (rootRef.current && rootRef.current.contains(event.target)) {\n            // If we intercepted an event for our instance, let it propagate down to the instance's onDrop handler\n            return;\n        }\n        event.preventDefault();\n        dragTargetsRef.current = [];\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function() {\n        if (preventDropOnDocument) {\n            document.addEventListener(\"dragover\", _utils_index__WEBPACK_IMPORTED_MODULE_3__.onDocumentDragOver, false);\n            document.addEventListener(\"drop\", onDocumentDrop, false);\n        }\n        return function() {\n            if (preventDropOnDocument) {\n                document.removeEventListener(\"dragover\", _utils_index__WEBPACK_IMPORTED_MODULE_3__.onDocumentDragOver);\n                document.removeEventListener(\"drop\", onDocumentDrop);\n            }\n        };\n    }, [\n        rootRef,\n        preventDropOnDocument\n    ]); // Auto focus the root when autoFocus is true\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function() {\n        if (!disabled && autoFocus && rootRef.current) {\n            rootRef.current.focus();\n        }\n        return function() {};\n    }, [\n        rootRef,\n        autoFocus,\n        disabled\n    ]);\n    var onErrCb = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function(e) {\n        if (onError) {\n            onError(e);\n        } else {\n            // Let the user know something's gone wrong if they haven't provided the onError cb.\n            console.error(e);\n        }\n    }, [\n        onError\n    ]);\n    var onDragEnterCb = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function(event) {\n        event.preventDefault(); // Persist here because we need the event later after getFilesFromEvent() is done\n        event.persist();\n        stopPropagation(event);\n        dragTargetsRef.current = [].concat(_toConsumableArray(dragTargetsRef.current), [\n            event.target\n        ]);\n        if ((0,_utils_index__WEBPACK_IMPORTED_MODULE_3__.isEvtWithFiles)(event)) {\n            Promise.resolve(getFilesFromEvent(event)).then(function(files) {\n                if ((0,_utils_index__WEBPACK_IMPORTED_MODULE_3__.isPropagationStopped)(event) && !noDragEventsBubbling) {\n                    return;\n                }\n                var fileCount = files.length;\n                var isDragAccept = fileCount > 0 && (0,_utils_index__WEBPACK_IMPORTED_MODULE_3__.allFilesAccepted)({\n                    files: files,\n                    accept: acceptAttr,\n                    minSize: minSize,\n                    maxSize: maxSize,\n                    multiple: multiple,\n                    maxFiles: maxFiles,\n                    validator: validator\n                });\n                var isDragReject = fileCount > 0 && !isDragAccept;\n                dispatch({\n                    isDragAccept: isDragAccept,\n                    isDragReject: isDragReject,\n                    isDragActive: true,\n                    type: \"setDraggedFiles\"\n                });\n                if (onDragEnter) {\n                    onDragEnter(event);\n                }\n            }).catch(function(e) {\n                return onErrCb(e);\n            });\n        }\n    }, [\n        getFilesFromEvent,\n        onDragEnter,\n        onErrCb,\n        noDragEventsBubbling,\n        acceptAttr,\n        minSize,\n        maxSize,\n        multiple,\n        maxFiles,\n        validator\n    ]);\n    var onDragOverCb = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function(event) {\n        event.preventDefault();\n        event.persist();\n        stopPropagation(event);\n        var hasFiles = (0,_utils_index__WEBPACK_IMPORTED_MODULE_3__.isEvtWithFiles)(event);\n        if (hasFiles && event.dataTransfer) {\n            try {\n                event.dataTransfer.dropEffect = \"copy\";\n            } catch (_unused) {}\n        /* eslint-disable-line no-empty */ }\n        if (hasFiles && onDragOver) {\n            onDragOver(event);\n        }\n        return false;\n    }, [\n        onDragOver,\n        noDragEventsBubbling\n    ]);\n    var onDragLeaveCb = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function(event) {\n        event.preventDefault();\n        event.persist();\n        stopPropagation(event); // Only deactivate once the dropzone and all children have been left\n        var targets = dragTargetsRef.current.filter(function(target) {\n            return rootRef.current && rootRef.current.contains(target);\n        }); // Make sure to remove a target present multiple times only once\n        // (Firefox may fire dragenter/dragleave multiple times on the same element)\n        var targetIdx = targets.indexOf(event.target);\n        if (targetIdx !== -1) {\n            targets.splice(targetIdx, 1);\n        }\n        dragTargetsRef.current = targets;\n        if (targets.length > 0) {\n            return;\n        }\n        dispatch({\n            type: \"setDraggedFiles\",\n            isDragActive: false,\n            isDragAccept: false,\n            isDragReject: false\n        });\n        if ((0,_utils_index__WEBPACK_IMPORTED_MODULE_3__.isEvtWithFiles)(event) && onDragLeave) {\n            onDragLeave(event);\n        }\n    }, [\n        rootRef,\n        onDragLeave,\n        noDragEventsBubbling\n    ]);\n    var setFiles = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function(files, event) {\n        var acceptedFiles = [];\n        var fileRejections = [];\n        files.forEach(function(file) {\n            var _fileAccepted = (0,_utils_index__WEBPACK_IMPORTED_MODULE_3__.fileAccepted)(file, acceptAttr), _fileAccepted2 = _slicedToArray(_fileAccepted, 2), accepted = _fileAccepted2[0], acceptError = _fileAccepted2[1];\n            var _fileMatchSize = (0,_utils_index__WEBPACK_IMPORTED_MODULE_3__.fileMatchSize)(file, minSize, maxSize), _fileMatchSize2 = _slicedToArray(_fileMatchSize, 2), sizeMatch = _fileMatchSize2[0], sizeError = _fileMatchSize2[1];\n            var customErrors = validator ? validator(file) : null;\n            if (accepted && sizeMatch && !customErrors) {\n                acceptedFiles.push(file);\n            } else {\n                var errors = [\n                    acceptError,\n                    sizeError\n                ];\n                if (customErrors) {\n                    errors = errors.concat(customErrors);\n                }\n                fileRejections.push({\n                    file: file,\n                    errors: errors.filter(function(e) {\n                        return e;\n                    })\n                });\n            }\n        });\n        if (!multiple && acceptedFiles.length > 1 || multiple && maxFiles >= 1 && acceptedFiles.length > maxFiles) {\n            // Reject everything and empty accepted files\n            acceptedFiles.forEach(function(file) {\n                fileRejections.push({\n                    file: file,\n                    errors: [\n                        _utils_index__WEBPACK_IMPORTED_MODULE_3__.TOO_MANY_FILES_REJECTION\n                    ]\n                });\n            });\n            acceptedFiles.splice(0);\n        }\n        dispatch({\n            acceptedFiles: acceptedFiles,\n            fileRejections: fileRejections,\n            isDragReject: fileRejections.length > 0,\n            type: \"setFiles\"\n        });\n        if (onDrop) {\n            onDrop(acceptedFiles, fileRejections, event);\n        }\n        if (fileRejections.length > 0 && onDropRejected) {\n            onDropRejected(fileRejections, event);\n        }\n        if (acceptedFiles.length > 0 && onDropAccepted) {\n            onDropAccepted(acceptedFiles, event);\n        }\n    }, [\n        dispatch,\n        multiple,\n        acceptAttr,\n        minSize,\n        maxSize,\n        maxFiles,\n        onDrop,\n        onDropAccepted,\n        onDropRejected,\n        validator\n    ]);\n    var onDropCb = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function(event) {\n        event.preventDefault(); // Persist here because we need the event later after getFilesFromEvent() is done\n        event.persist();\n        stopPropagation(event);\n        dragTargetsRef.current = [];\n        if ((0,_utils_index__WEBPACK_IMPORTED_MODULE_3__.isEvtWithFiles)(event)) {\n            Promise.resolve(getFilesFromEvent(event)).then(function(files) {\n                if ((0,_utils_index__WEBPACK_IMPORTED_MODULE_3__.isPropagationStopped)(event) && !noDragEventsBubbling) {\n                    return;\n                }\n                setFiles(files, event);\n            }).catch(function(e) {\n                return onErrCb(e);\n            });\n        }\n        dispatch({\n            type: \"reset\"\n        });\n    }, [\n        getFilesFromEvent,\n        setFiles,\n        onErrCb,\n        noDragEventsBubbling\n    ]); // Fn for opening the file dialog programmatically\n    var openFileDialog = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function() {\n        // No point to use FS access APIs if context is not secure\n        // https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts#feature_detection\n        if (fsAccessApiWorksRef.current) {\n            dispatch({\n                type: \"openDialog\"\n            });\n            onFileDialogOpenCb(); // https://developer.mozilla.org/en-US/docs/Web/API/window/showOpenFilePicker\n            var opts = {\n                multiple: multiple,\n                types: pickerTypes\n            };\n            window.showOpenFilePicker(opts).then(function(handles) {\n                return getFilesFromEvent(handles);\n            }).then(function(files) {\n                setFiles(files, null);\n                dispatch({\n                    type: \"closeDialog\"\n                });\n            }).catch(function(e) {\n                // AbortError means the user canceled\n                if ((0,_utils_index__WEBPACK_IMPORTED_MODULE_3__.isAbort)(e)) {\n                    onFileDialogCancelCb(e);\n                    dispatch({\n                        type: \"closeDialog\"\n                    });\n                } else if ((0,_utils_index__WEBPACK_IMPORTED_MODULE_3__.isSecurityError)(e)) {\n                    fsAccessApiWorksRef.current = false; // CORS, so cannot use this API\n                    // Try using the input\n                    if (inputRef.current) {\n                        inputRef.current.value = null;\n                        inputRef.current.click();\n                    } else {\n                        onErrCb(new Error(\"Cannot open the file picker because the https://developer.mozilla.org/en-US/docs/Web/API/File_System_Access_API is not supported and no <input> was provided.\"));\n                    }\n                } else {\n                    onErrCb(e);\n                }\n            });\n            return;\n        }\n        if (inputRef.current) {\n            dispatch({\n                type: \"openDialog\"\n            });\n            onFileDialogOpenCb();\n            inputRef.current.value = null;\n            inputRef.current.click();\n        }\n    }, [\n        dispatch,\n        onFileDialogOpenCb,\n        onFileDialogCancelCb,\n        useFsAccessApi,\n        setFiles,\n        onErrCb,\n        pickerTypes,\n        multiple\n    ]); // Cb to open the file dialog when SPACE/ENTER occurs on the dropzone\n    var onKeyDownCb = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function(event) {\n        // Ignore keyboard events bubbling up the DOM tree\n        if (!rootRef.current || !rootRef.current.isEqualNode(event.target)) {\n            return;\n        }\n        if (event.key === \" \" || event.key === \"Enter\" || event.keyCode === 32 || event.keyCode === 13) {\n            event.preventDefault();\n            openFileDialog();\n        }\n    }, [\n        rootRef,\n        openFileDialog\n    ]); // Update focus state for the dropzone\n    var onFocusCb = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function() {\n        dispatch({\n            type: \"focus\"\n        });\n    }, []);\n    var onBlurCb = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function() {\n        dispatch({\n            type: \"blur\"\n        });\n    }, []); // Cb to open the file dialog when click occurs on the dropzone\n    var onClickCb = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function() {\n        if (noClick) {\n            return;\n        } // In IE11/Edge the file-browser dialog is blocking, therefore, use setTimeout()\n        // to ensure React can handle state changes\n        // See: https://github.com/react-dropzone/react-dropzone/issues/450\n        if ((0,_utils_index__WEBPACK_IMPORTED_MODULE_3__.isIeOrEdge)()) {\n            setTimeout(openFileDialog, 0);\n        } else {\n            openFileDialog();\n        }\n    }, [\n        noClick,\n        openFileDialog\n    ]);\n    var composeHandler = function composeHandler(fn) {\n        return disabled ? null : fn;\n    };\n    var composeKeyboardHandler = function composeKeyboardHandler(fn) {\n        return noKeyboard ? null : composeHandler(fn);\n    };\n    var composeDragHandler = function composeDragHandler(fn) {\n        return noDrag ? null : composeHandler(fn);\n    };\n    var stopPropagation = function stopPropagation(event) {\n        if (noDragEventsBubbling) {\n            event.stopPropagation();\n        }\n    };\n    var getRootProps = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(function() {\n        return function() {\n            var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, _ref2$refKey = _ref2.refKey, refKey = _ref2$refKey === void 0 ? \"ref\" : _ref2$refKey, role = _ref2.role, onKeyDown = _ref2.onKeyDown, onFocus = _ref2.onFocus, onBlur = _ref2.onBlur, onClick = _ref2.onClick, onDragEnter = _ref2.onDragEnter, onDragOver = _ref2.onDragOver, onDragLeave = _ref2.onDragLeave, onDrop = _ref2.onDrop, rest = _objectWithoutProperties(_ref2, _excluded3);\n            return _objectSpread(_objectSpread(_defineProperty({\n                onKeyDown: composeKeyboardHandler((0,_utils_index__WEBPACK_IMPORTED_MODULE_3__.composeEventHandlers)(onKeyDown, onKeyDownCb)),\n                onFocus: composeKeyboardHandler((0,_utils_index__WEBPACK_IMPORTED_MODULE_3__.composeEventHandlers)(onFocus, onFocusCb)),\n                onBlur: composeKeyboardHandler((0,_utils_index__WEBPACK_IMPORTED_MODULE_3__.composeEventHandlers)(onBlur, onBlurCb)),\n                onClick: composeHandler((0,_utils_index__WEBPACK_IMPORTED_MODULE_3__.composeEventHandlers)(onClick, onClickCb)),\n                onDragEnter: composeDragHandler((0,_utils_index__WEBPACK_IMPORTED_MODULE_3__.composeEventHandlers)(onDragEnter, onDragEnterCb)),\n                onDragOver: composeDragHandler((0,_utils_index__WEBPACK_IMPORTED_MODULE_3__.composeEventHandlers)(onDragOver, onDragOverCb)),\n                onDragLeave: composeDragHandler((0,_utils_index__WEBPACK_IMPORTED_MODULE_3__.composeEventHandlers)(onDragLeave, onDragLeaveCb)),\n                onDrop: composeDragHandler((0,_utils_index__WEBPACK_IMPORTED_MODULE_3__.composeEventHandlers)(onDrop, onDropCb)),\n                role: typeof role === \"string\" && role !== \"\" ? role : \"presentation\"\n            }, refKey, rootRef), !disabled && !noKeyboard ? {\n                tabIndex: 0\n            } : {}), rest);\n        };\n    }, [\n        rootRef,\n        onKeyDownCb,\n        onFocusCb,\n        onBlurCb,\n        onClickCb,\n        onDragEnterCb,\n        onDragOverCb,\n        onDragLeaveCb,\n        onDropCb,\n        noKeyboard,\n        noDrag,\n        disabled\n    ]);\n    var onInputElementClick = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function(event) {\n        event.stopPropagation();\n    }, []);\n    var getInputProps = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(function() {\n        return function() {\n            var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, _ref3$refKey = _ref3.refKey, refKey = _ref3$refKey === void 0 ? \"ref\" : _ref3$refKey, onChange = _ref3.onChange, onClick = _ref3.onClick, rest = _objectWithoutProperties(_ref3, _excluded4);\n            var inputProps = _defineProperty({\n                accept: acceptAttr,\n                multiple: multiple,\n                type: \"file\",\n                style: {\n                    border: 0,\n                    clip: \"rect(0, 0, 0, 0)\",\n                    clipPath: \"inset(50%)\",\n                    height: \"1px\",\n                    margin: \"0 -1px -1px 0\",\n                    overflow: \"hidden\",\n                    padding: 0,\n                    position: \"absolute\",\n                    width: \"1px\",\n                    whiteSpace: \"nowrap\"\n                },\n                onChange: composeHandler((0,_utils_index__WEBPACK_IMPORTED_MODULE_3__.composeEventHandlers)(onChange, onDropCb)),\n                onClick: composeHandler((0,_utils_index__WEBPACK_IMPORTED_MODULE_3__.composeEventHandlers)(onClick, onInputElementClick)),\n                tabIndex: -1\n            }, refKey, inputRef);\n            return _objectSpread(_objectSpread({}, inputProps), rest);\n        };\n    }, [\n        inputRef,\n        accept,\n        multiple,\n        onDropCb,\n        disabled\n    ]);\n    return _objectSpread(_objectSpread({}, state), {}, {\n        isFocused: isFocused && !disabled,\n        getRootProps: getRootProps,\n        getInputProps: getInputProps,\n        rootRef: rootRef,\n        inputRef: inputRef,\n        open: composeHandler(openFileDialog)\n    });\n}\n/**\n * @param {DropzoneState} state\n * @param {{type: string} & DropzoneState} action\n * @returns {DropzoneState}\n */ function reducer(state, action) {\n    /* istanbul ignore next */ switch(action.type){\n        case \"focus\":\n            return _objectSpread(_objectSpread({}, state), {}, {\n                isFocused: true\n            });\n        case \"blur\":\n            return _objectSpread(_objectSpread({}, state), {}, {\n                isFocused: false\n            });\n        case \"openDialog\":\n            return _objectSpread(_objectSpread({}, initialState), {}, {\n                isFileDialogActive: true\n            });\n        case \"closeDialog\":\n            return _objectSpread(_objectSpread({}, state), {}, {\n                isFileDialogActive: false\n            });\n        case \"setDraggedFiles\":\n            return _objectSpread(_objectSpread({}, state), {}, {\n                isDragActive: action.isDragActive,\n                isDragAccept: action.isDragAccept,\n                isDragReject: action.isDragReject\n            });\n        case \"setFiles\":\n            return _objectSpread(_objectSpread({}, state), {}, {\n                acceptedFiles: action.acceptedFiles,\n                fileRejections: action.fileRejections,\n                isDragReject: action.isDragReject\n            });\n        case \"reset\":\n            return _objectSpread({}, initialState);\n        default:\n            return state;\n    }\n}\nfunction noop() {}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtZHJvcHpvbmUvZGlzdC9lcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQSxJQUFJQSxZQUFZO0lBQUM7Q0FBVyxFQUN4QkMsYUFBYTtJQUFDO0NBQU8sRUFDckJDLGFBQWE7SUFBQztJQUFVO0lBQVE7SUFBYTtJQUFXO0lBQVU7SUFBVztJQUFlO0lBQWM7SUFBZTtDQUFTLEVBQ2xJQyxhQUFhO0lBQUM7SUFBVTtJQUFZO0NBQVU7QUFFbEQsU0FBU0MsbUJBQW1CQyxHQUFHO0lBQUksT0FBT0MsbUJBQW1CRCxRQUFRRSxpQkFBaUJGLFFBQVFHLDRCQUE0QkgsUUFBUUk7QUFBc0I7QUFFeEosU0FBU0E7SUFBdUIsTUFBTSxJQUFJQyxVQUFVO0FBQXlJO0FBRTdMLFNBQVNILGlCQUFpQkksSUFBSTtJQUFJLElBQUksT0FBT0MsV0FBVyxlQUFlRCxJQUFJLENBQUNDLE9BQU9DLFFBQVEsQ0FBQyxJQUFJLFFBQVFGLElBQUksQ0FBQyxhQUFhLElBQUksTUFBTSxPQUFPRyxNQUFNQyxJQUFJLENBQUNKO0FBQU87QUFFN0osU0FBU0wsbUJBQW1CRCxHQUFHO0lBQUksSUFBSVMsTUFBTUUsT0FBTyxDQUFDWCxNQUFNLE9BQU9ZLGtCQUFrQlo7QUFBTTtBQUUxRixTQUFTYSxlQUFlYixHQUFHLEVBQUVjLENBQUM7SUFBSSxPQUFPQyxnQkFBZ0JmLFFBQVFnQixzQkFBc0JoQixLQUFLYyxNQUFNWCw0QkFBNEJILEtBQUtjLE1BQU1HO0FBQW9CO0FBRTdKLFNBQVNBO0lBQXFCLE1BQU0sSUFBSVosVUFBVTtBQUE4STtBQUVoTSxTQUFTRiw0QkFBNEJlLENBQUMsRUFBRUMsTUFBTTtJQUFJLElBQUksQ0FBQ0QsR0FBRztJQUFRLElBQUksT0FBT0EsTUFBTSxVQUFVLE9BQU9OLGtCQUFrQk0sR0FBR0M7SUFBUyxJQUFJQyxJQUFJQyxPQUFPQyxTQUFTLENBQUNDLFFBQVEsQ0FBQ0MsSUFBSSxDQUFDTixHQUFH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Q0Y7QUFDQTs7OztDQUlDLEdBRUQsU0FBU3hELFFBQVFFLEtBQUssRUFBRW1HLE1BQU07SUFDNUIsd0JBQXdCLEdBQ3hCLE9BQVFBLE9BQU8xRixJQUFJO1FBQ2pCLEtBQUs7WUFDSCxPQUFPdEgsY0FBY0EsY0FBYyxDQUFDLEdBQUc2RyxRQUFRLENBQUMsR0FBRztnQkFDakRuQixXQUFXO1lBQ2I7UUFFRixLQUFLO1lBQ0gsT0FBTzFGLGNBQWNBLGNBQWMsQ0FBQyxHQUFHNkcsUUFBUSxDQUFDLEdBQUc7Z0JBQ2pEbkIsV0FBVztZQUNiO1FBRUYsS0FBSztZQUNILE9BQU8xRixjQUFjQSxjQUFjLENBQUMsR0FBR3lGLGVBQWUsQ0FBQyxHQUFHO2dCQUN4REUsb0JBQW9CO1lBQ3RCO1FBRUYsS0FBSztZQUNILE9BQU8zRixjQUFjQSxjQUFjLENBQUMsR0FBRzZHLFFBQVEsQ0FBQyxHQUFHO2dCQUNqRGxCLG9CQUFvQjtZQUN0QjtRQUVGLEtBQUs7WUFDSCxPQUFPM0YsY0FBY0EsY0FBYyxDQUFDLEdBQUc2RyxRQUFRLENBQUMsR0FBRztnQkFDakRqQixjQUFjb0gsT0FBT3BILFlBQVk7Z0JBQ2pDQyxjQUFjbUgsT0FBT25ILFlBQVk7Z0JBQ2pDQyxjQUFja0gsT0FBT2xILFlBQVk7WUFDbkM7UUFFRixLQUFLO1lBQ0gsT0FBTzlGLGNBQWNBLGNBQWMsQ0FBQyxHQUFHNkcsUUFBUSxDQUFDLEdBQUc7Z0JBQ2pEZCxlQUFlaUgsT0FBT2pILGFBQWE7Z0JBQ25DQyxnQkFBZ0JnSCxPQUFPaEgsY0FBYztnQkFDckNGLGNBQWNrSCxPQUFPbEgsWUFBWTtZQUNuQztRQUVGLEtBQUs7WUFDSCxPQUFPOUYsY0FBYyxDQUFDLEdBQUd5RjtRQUUzQjtZQUNFLE9BQU9vQjtJQUNYO0FBQ0Y7QUFFQSxTQUFTUCxRQUFRO0FBRW1CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW1hZ2UtZ2FsbGVyeS8uL25vZGVfbW9kdWxlcy9yZWFjdC1kcm9wem9uZS9kaXN0L2VzL2luZGV4LmpzP2NhNmMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9leGNsdWRlZCA9IFtcImNoaWxkcmVuXCJdLFxuICAgIF9leGNsdWRlZDIgPSBbXCJvcGVuXCJdLFxuICAgIF9leGNsdWRlZDMgPSBbXCJyZWZLZXlcIiwgXCJyb2xlXCIsIFwib25LZXlEb3duXCIsIFwib25Gb2N1c1wiLCBcIm9uQmx1clwiLCBcIm9uQ2xpY2tcIiwgXCJvbkRyYWdFbnRlclwiLCBcIm9uRHJhZ092ZXJcIiwgXCJvbkRyYWdMZWF2ZVwiLCBcIm9uRHJvcFwiXSxcbiAgICBfZXhjbHVkZWQ0ID0gW1wicmVmS2V5XCIsIFwib25DaGFuZ2VcIiwgXCJvbkNsaWNrXCJdO1xuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7IH1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHsgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgaXRlcltTeW1ib2wuaXRlcmF0b3JdICE9IG51bGwgfHwgaXRlcltcIkBAaXRlcmF0b3JcIl0gIT0gbnVsbCkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7IH1cblxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkoYXJyKTsgfVxuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHsgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTsgfVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgeyB2YXIgX2kgPSBhcnIgPT0gbnVsbCA/IG51bGwgOiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGFycltTeW1ib2wuaXRlcmF0b3JdIHx8IGFycltcIkBAaXRlcmF0b3JcIl07IGlmIChfaSA9PSBudWxsKSByZXR1cm47IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX3MsIF9lOyB0cnkgeyBmb3IgKF9pID0gX2kuY2FsbChhcnIpOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH1cblxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyOyB9XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBlbnVtZXJhYmxlT25seSAmJiAoc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pKSwga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBudWxsICE9IGFyZ3VtZW50c1tpXSA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpICUgMiA/IG93bktleXMoT2JqZWN0KHNvdXJjZSksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpIDogb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7IHZhciBrZXksIGk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTsgdmFyIGtleSwgaTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbi8qIGVzbGludCBwcmVmZXItdGVtcGxhdGU6IDAgKi9cbmltcG9ydCBSZWFjdCwgeyBmb3J3YXJkUmVmLCBGcmFnbWVudCwgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlSW1wZXJhdGl2ZUhhbmRsZSwgdXNlTWVtbywgdXNlUmVkdWNlciwgdXNlUmVmIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gXCJwcm9wLXR5cGVzXCI7XG5pbXBvcnQgeyBmcm9tRXZlbnQgfSBmcm9tIFwiZmlsZS1zZWxlY3RvclwiO1xuaW1wb3J0IHsgYWNjZXB0UHJvcEFzQWNjZXB0QXR0ciwgYWxsRmlsZXNBY2NlcHRlZCwgY29tcG9zZUV2ZW50SGFuZGxlcnMsIGZpbGVBY2NlcHRlZCwgZmlsZU1hdGNoU2l6ZSwgY2FuVXNlRmlsZVN5c3RlbUFjY2Vzc0FQSSwgaXNBYm9ydCwgaXNFdnRXaXRoRmlsZXMsIGlzSWVPckVkZ2UsIGlzUHJvcGFnYXRpb25TdG9wcGVkLCBpc1NlY3VyaXR5RXJyb3IsIG9uRG9jdW1lbnREcmFnT3ZlciwgcGlja2VyT3B0aW9uc0Zyb21BY2NlcHQsIFRPT19NQU5ZX0ZJTEVTX1JFSkVDVElPTiB9IGZyb20gXCIuL3V0aWxzL2luZGV4XCI7XG4vKipcbiAqIENvbnZlbmllbmNlIHdyYXBwZXIgY29tcG9uZW50IGZvciB0aGUgYHVzZURyb3B6b25lYCBob29rXG4gKlxuICogYGBganN4XG4gKiA8RHJvcHpvbmU+XG4gKiAgIHsoe2dldFJvb3RQcm9wcywgZ2V0SW5wdXRQcm9wc30pID0+IChcbiAqICAgICA8ZGl2IHsuLi5nZXRSb290UHJvcHMoKX0+XG4gKiAgICAgICA8aW5wdXQgey4uLmdldElucHV0UHJvcHMoKX0gLz5cbiAqICAgICAgIDxwPkRyYWcgJ24nIGRyb3Agc29tZSBmaWxlcyBoZXJlLCBvciBjbGljayB0byBzZWxlY3QgZmlsZXM8L3A+XG4gKiAgICAgPC9kaXY+XG4gKiAgICl9XG4gKiA8L0Ryb3B6b25lPlxuICogYGBgXG4gKi9cblxudmFyIERyb3B6b25lID0gLyojX19QVVJFX18qL2ZvcndhcmRSZWYoZnVuY3Rpb24gKF9yZWYsIHJlZikge1xuICB2YXIgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuLFxuICAgICAgcGFyYW1zID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIF9leGNsdWRlZCk7XG5cbiAgdmFyIF91c2VEcm9wem9uZSA9IHVzZURyb3B6b25lKHBhcmFtcyksXG4gICAgICBvcGVuID0gX3VzZURyb3B6b25lLm9wZW4sXG4gICAgICBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfdXNlRHJvcHpvbmUsIF9leGNsdWRlZDIpO1xuXG4gIHVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9wZW46IG9wZW5cbiAgICB9O1xuICB9LCBbb3Blbl0pOyAvLyBUT0RPOiBGaWd1cmUgb3V0IHdoeSByZWFjdC1zdHlsZWd1aWRpc3QgY2Fubm90IGNyZWF0ZSBkb2NzIGlmIHdlIGRvbid0IHJldHVybiBhIGpzeCBlbGVtZW50XG5cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLCBjaGlsZHJlbihfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHByb3BzKSwge30sIHtcbiAgICBvcGVuOiBvcGVuXG4gIH0pKSk7XG59KTtcbkRyb3B6b25lLmRpc3BsYXlOYW1lID0gXCJEcm9wem9uZVwiOyAvLyBBZGQgZGVmYXVsdCBwcm9wcyBmb3IgcmVhY3QtZG9jZ2VuXG5cbnZhciBkZWZhdWx0UHJvcHMgPSB7XG4gIGRpc2FibGVkOiBmYWxzZSxcbiAgZ2V0RmlsZXNGcm9tRXZlbnQ6IGZyb21FdmVudCxcbiAgbWF4U2l6ZTogSW5maW5pdHksXG4gIG1pblNpemU6IDAsXG4gIG11bHRpcGxlOiB0cnVlLFxuICBtYXhGaWxlczogMCxcbiAgcHJldmVudERyb3BPbkRvY3VtZW50OiB0cnVlLFxuICBub0NsaWNrOiBmYWxzZSxcbiAgbm9LZXlib2FyZDogZmFsc2UsXG4gIG5vRHJhZzogZmFsc2UsXG4gIG5vRHJhZ0V2ZW50c0J1YmJsaW5nOiBmYWxzZSxcbiAgdmFsaWRhdG9yOiBudWxsLFxuICB1c2VGc0FjY2Vzc0FwaTogZmFsc2UsXG4gIGF1dG9Gb2N1czogZmFsc2Vcbn07XG5Ecm9wem9uZS5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG5Ecm9wem9uZS5wcm9wVHlwZXMgPSB7XG4gIC8qKlxuICAgKiBSZW5kZXIgZnVuY3Rpb24gdGhhdCBleHBvc2VzIHRoZSBkcm9wem9uZSBzdGF0ZSBhbmQgcHJvcCBnZXR0ZXIgZm5zXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcGFyYW1zLmdldFJvb3RQcm9wcyBSZXR1cm5zIHRoZSBwcm9wcyB5b3Ugc2hvdWxkIGFwcGx5IHRvIHRoZSByb290IGRyb3AgY29udGFpbmVyIHlvdSByZW5kZXJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcGFyYW1zLmdldElucHV0UHJvcHMgUmV0dXJucyB0aGUgcHJvcHMgeW91IHNob3VsZCBhcHBseSB0byBoaWRkZW4gZmlsZSBpbnB1dCB5b3UgcmVuZGVyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHBhcmFtcy5vcGVuIE9wZW4gdGhlIG5hdGl2ZSBmaWxlIHNlbGVjdGlvbiBkaWFsb2dcbiAgICogQHBhcmFtIHtib29sZWFufSBwYXJhbXMuaXNGb2N1c2VkIERyb3B6b25lIGFyZWEgaXMgaW4gZm9jdXNcbiAgICogQHBhcmFtIHtib29sZWFufSBwYXJhbXMuaXNGaWxlRGlhbG9nQWN0aXZlIEZpbGUgZGlhbG9nIGlzIG9wZW5lZFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHBhcmFtcy5pc0RyYWdBY3RpdmUgQWN0aXZlIGRyYWcgaXMgaW4gcHJvZ3Jlc3NcbiAgICogQHBhcmFtIHtib29sZWFufSBwYXJhbXMuaXNEcmFnQWNjZXB0IERyYWdnZWQgZmlsZXMgYXJlIGFjY2VwdGVkXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcGFyYW1zLmlzRHJhZ1JlamVjdCBTb21lIGRyYWdnZWQgZmlsZXMgYXJlIHJlamVjdGVkXG4gICAqIEBwYXJhbSB7RmlsZVtdfSBwYXJhbXMuYWNjZXB0ZWRGaWxlcyBBY2NlcHRlZCBmaWxlc1xuICAgKiBAcGFyYW0ge0ZpbGVSZWplY3Rpb25bXX0gcGFyYW1zLmZpbGVSZWplY3Rpb25zIFJlamVjdGVkIGZpbGVzIGFuZCB3aHkgdGhleSB3ZXJlIHJlamVjdGVkXG4gICAqL1xuICBjaGlsZHJlbjogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIFNldCBhY2NlcHRlZCBmaWxlIHR5cGVzLlxuICAgKiBDaGVja291dCBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvd2luZG93L3Nob3dPcGVuRmlsZVBpY2tlciB0eXBlcyBvcHRpb24gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAqIEtlZXAgaW4gbWluZCB0aGF0IG1pbWUgdHlwZSBkZXRlcm1pbmF0aW9uIGlzIG5vdCByZWxpYWJsZSBhY3Jvc3MgcGxhdGZvcm1zLiBDU1YgZmlsZXMsXG4gICAqIGZvciBleGFtcGxlLCBhcmUgcmVwb3J0ZWQgYXMgdGV4dC9wbGFpbiB1bmRlciBtYWNPUyBidXQgYXMgYXBwbGljYXRpb24vdm5kLm1zLWV4Y2VsIHVuZGVyXG4gICAqIFdpbmRvd3MuIEluIHNvbWUgY2FzZXMgdGhlcmUgbWlnaHQgbm90IGJlIGEgbWltZSB0eXBlIHNldCBhdCBhbGwgKGh0dHBzOi8vZ2l0aHViLmNvbS9yZWFjdC1kcm9wem9uZS9yZWFjdC1kcm9wem9uZS9pc3N1ZXMvMjc2KS5cbiAgICovXG4gIGFjY2VwdDogUHJvcFR5cGVzLm9iamVjdE9mKFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5zdHJpbmcpKSxcblxuICAvKipcbiAgICogQWxsb3cgZHJhZyAnbicgZHJvcCAob3Igc2VsZWN0aW9uIGZyb20gdGhlIGZpbGUgZGlhbG9nKSBvZiBtdWx0aXBsZSBmaWxlc1xuICAgKi9cbiAgbXVsdGlwbGU6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBJZiBmYWxzZSwgYWxsb3cgZHJvcHBlZCBpdGVtcyB0byB0YWtlIG92ZXIgdGhlIGN1cnJlbnQgYnJvd3NlciB3aW5kb3dcbiAgICovXG4gIHByZXZlbnREcm9wT25Eb2N1bWVudDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIElmIHRydWUsIGRpc2FibGVzIGNsaWNrIHRvIG9wZW4gdGhlIG5hdGl2ZSBmaWxlIHNlbGVjdGlvbiBkaWFsb2dcbiAgICovXG4gIG5vQ2xpY2s6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBJZiB0cnVlLCBkaXNhYmxlcyBTUEFDRS9FTlRFUiB0byBvcGVuIHRoZSBuYXRpdmUgZmlsZSBzZWxlY3Rpb24gZGlhbG9nLlxuICAgKiBOb3RlIHRoYXQgaXQgYWxzbyBzdG9wcyB0cmFja2luZyB0aGUgZm9jdXMgc3RhdGUuXG4gICAqL1xuICBub0tleWJvYXJkOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogSWYgdHJ1ZSwgZGlzYWJsZXMgZHJhZyAnbicgZHJvcFxuICAgKi9cbiAgbm9EcmFnOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogSWYgdHJ1ZSwgc3RvcHMgZHJhZyBldmVudCBwcm9wYWdhdGlvbiB0byBwYXJlbnRzXG4gICAqL1xuICBub0RyYWdFdmVudHNCdWJibGluZzogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIE1pbmltdW0gZmlsZSBzaXplIChpbiBieXRlcylcbiAgICovXG4gIG1pblNpemU6IFByb3BUeXBlcy5udW1iZXIsXG5cbiAgLyoqXG4gICAqIE1heGltdW0gZmlsZSBzaXplIChpbiBieXRlcylcbiAgICovXG4gIG1heFNpemU6IFByb3BUeXBlcy5udW1iZXIsXG5cbiAgLyoqXG4gICAqIE1heGltdW0gYWNjZXB0ZWQgbnVtYmVyIG9mIGZpbGVzXG4gICAqIFRoZSBkZWZhdWx0IHZhbHVlIGlzIDAgd2hpY2ggbWVhbnMgdGhlcmUgaXMgbm8gbGltaXRhdGlvbiB0byBob3cgbWFueSBmaWxlcyBhcmUgYWNjZXB0ZWQuXG4gICAqL1xuICBtYXhGaWxlczogUHJvcFR5cGVzLm51bWJlcixcblxuICAvKipcbiAgICogRW5hYmxlL2Rpc2FibGUgdGhlIGRyb3B6b25lXG4gICAqL1xuICBkaXNhYmxlZDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIFVzZSB0aGlzIHRvIHByb3ZpZGUgYSBjdXN0b20gZmlsZSBhZ2dyZWdhdG9yXG4gICAqXG4gICAqIEBwYXJhbSB7KERyYWdFdmVudHxFdmVudCl9IGV2ZW50IEEgZHJhZyBldmVudCBvciBpbnB1dCBjaGFuZ2UgZXZlbnQgKGlmIGZpbGVzIHdlcmUgc2VsZWN0ZWQgdmlhIHRoZSBmaWxlIGRpYWxvZylcbiAgICovXG4gIGdldEZpbGVzRnJvbUV2ZW50OiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQ2IgZm9yIHdoZW4gY2xvc2luZyB0aGUgZmlsZSBkaWFsb2cgd2l0aCBubyBzZWxlY3Rpb25cbiAgICovXG4gIG9uRmlsZURpYWxvZ0NhbmNlbDogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIENiIGZvciB3aGVuIG9wZW5pbmcgdGhlIGZpbGUgZGlhbG9nXG4gICAqL1xuICBvbkZpbGVEaWFsb2dPcGVuOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogU2V0IHRvIHRydWUgdG8gdXNlIHRoZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRmlsZV9TeXN0ZW1fQWNjZXNzX0FQSVxuICAgKiB0byBvcGVuIHRoZSBmaWxlIHBpY2tlciBpbnN0ZWFkIG9mIHVzaW5nIGFuIGA8aW5wdXQgdHlwZT1cImZpbGVcIj5gIGNsaWNrIGV2ZW50LlxuICAgKi9cbiAgdXNlRnNBY2Nlc3NBcGk6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBTZXQgdG8gdHJ1ZSB0byBmb2N1cyB0aGUgcm9vdCBlbGVtZW50IG9uIHJlbmRlclxuICAgKi9cbiAgYXV0b0ZvY3VzOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogQ2IgZm9yIHdoZW4gdGhlIGBkcmFnZW50ZXJgIGV2ZW50IG9jY3Vycy5cbiAgICpcbiAgICogQHBhcmFtIHtEcmFnRXZlbnR9IGV2ZW50XG4gICAqL1xuICBvbkRyYWdFbnRlcjogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIENiIGZvciB3aGVuIHRoZSBgZHJhZ2xlYXZlYCBldmVudCBvY2N1cnNcbiAgICpcbiAgICogQHBhcmFtIHtEcmFnRXZlbnR9IGV2ZW50XG4gICAqL1xuICBvbkRyYWdMZWF2ZTogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIENiIGZvciB3aGVuIHRoZSBgZHJhZ292ZXJgIGV2ZW50IG9jY3Vyc1xuICAgKlxuICAgKiBAcGFyYW0ge0RyYWdFdmVudH0gZXZlbnRcbiAgICovXG4gIG9uRHJhZ092ZXI6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBDYiBmb3Igd2hlbiB0aGUgYGRyb3BgIGV2ZW50IG9jY3Vycy5cbiAgICogTm90ZSB0aGF0IHRoaXMgY2FsbGJhY2sgaXMgaW52b2tlZCBhZnRlciB0aGUgYGdldEZpbGVzRnJvbUV2ZW50YCBjYWxsYmFjayBpcyBkb25lLlxuICAgKlxuICAgKiBGaWxlcyBhcmUgYWNjZXB0ZWQgb3IgcmVqZWN0ZWQgYmFzZWQgb24gdGhlIGBhY2NlcHRgLCBgbXVsdGlwbGVgLCBgbWluU2l6ZWAgYW5kIGBtYXhTaXplYCBwcm9wcy5cbiAgICogYGFjY2VwdGAgbXVzdCBiZSBhIHZhbGlkIFtNSU1FIHR5cGVdKGh0dHA6Ly93d3cuaWFuYS5vcmcvYXNzaWdubWVudHMvbWVkaWEtdHlwZXMvbWVkaWEtdHlwZXMueGh0bWwpIGFjY29yZGluZyB0byBbaW5wdXQgZWxlbWVudCBzcGVjaWZpY2F0aW9uXShodHRwczovL3d3dy53My5vcmcvd2lraS9IVE1ML0VsZW1lbnRzL2lucHV0L2ZpbGUpIG9yIGEgdmFsaWQgZmlsZSBleHRlbnNpb24uXG4gICAqIElmIGBtdWx0aXBsZWAgaXMgc2V0IHRvIGZhbHNlIGFuZCBhZGRpdGlvbmFsIGZpbGVzIGFyZSBkcm9wcGVkLFxuICAgKiBhbGwgZmlsZXMgYmVzaWRlcyB0aGUgZmlyc3Qgd2lsbCBiZSByZWplY3RlZC5cbiAgICogQW55IGZpbGUgd2hpY2ggZG9lcyBub3QgaGF2ZSBhIHNpemUgaW4gdGhlIFtgbWluU2l6ZWAsIGBtYXhTaXplYF0gcmFuZ2UsIHdpbGwgYmUgcmVqZWN0ZWQgYXMgd2VsbC5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoZSBgb25Ecm9wYCBjYWxsYmFjayB3aWxsIGFsd2F5cyBiZSBpbnZva2VkIHJlZ2FyZGxlc3MgaWYgdGhlIGRyb3BwZWQgZmlsZXMgd2VyZSBhY2NlcHRlZCBvciByZWplY3RlZC5cbiAgICogSWYgeW91J2QgbGlrZSB0byByZWFjdCB0byBhIHNwZWNpZmljIHNjZW5hcmlvLCB1c2UgdGhlIGBvbkRyb3BBY2NlcHRlZGAvYG9uRHJvcFJlamVjdGVkYCBwcm9wcy5cbiAgICpcbiAgICogYG9uRHJvcGAgd2lsbCBwcm92aWRlIHlvdSB3aXRoIGFuIGFycmF5IG9mIFtGaWxlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRmlsZSkgb2JqZWN0cyB3aGljaCB5b3UgY2FuIHRoZW4gcHJvY2VzcyBhbmQgc2VuZCB0byBhIHNlcnZlci5cbiAgICogRm9yIGV4YW1wbGUsIHdpdGggW1N1cGVyQWdlbnRdKGh0dHBzOi8vZ2l0aHViLmNvbS92aXNpb25tZWRpYS9zdXBlcmFnZW50KSBhcyBhIGh0dHAvYWpheCBsaWJyYXJ5OlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBmdW5jdGlvbiBvbkRyb3AoYWNjZXB0ZWRGaWxlcykge1xuICAgKiAgIGNvbnN0IHJlcSA9IHJlcXVlc3QucG9zdCgnL3VwbG9hZCcpXG4gICAqICAgYWNjZXB0ZWRGaWxlcy5mb3JFYWNoKGZpbGUgPT4ge1xuICAgKiAgICAgcmVxLmF0dGFjaChmaWxlLm5hbWUsIGZpbGUpXG4gICAqICAgfSlcbiAgICogICByZXEuZW5kKGNhbGxiYWNrKVxuICAgKiB9XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0ge0ZpbGVbXX0gYWNjZXB0ZWRGaWxlc1xuICAgKiBAcGFyYW0ge0ZpbGVSZWplY3Rpb25bXX0gZmlsZVJlamVjdGlvbnNcbiAgICogQHBhcmFtIHsoRHJhZ0V2ZW50fEV2ZW50KX0gZXZlbnQgQSBkcmFnIGV2ZW50IG9yIGlucHV0IGNoYW5nZSBldmVudCAoaWYgZmlsZXMgd2VyZSBzZWxlY3RlZCB2aWEgdGhlIGZpbGUgZGlhbG9nKVxuICAgKi9cbiAgb25Ecm9wOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQ2IgZm9yIHdoZW4gdGhlIGBkcm9wYCBldmVudCBvY2N1cnMuXG4gICAqIE5vdGUgdGhhdCBpZiBubyBmaWxlcyBhcmUgYWNjZXB0ZWQsIHRoaXMgY2FsbGJhY2sgaXMgbm90IGludm9rZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7RmlsZVtdfSBmaWxlc1xuICAgKiBAcGFyYW0geyhEcmFnRXZlbnR8RXZlbnQpfSBldmVudFxuICAgKi9cbiAgb25Ecm9wQWNjZXB0ZWQ6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBDYiBmb3Igd2hlbiB0aGUgYGRyb3BgIGV2ZW50IG9jY3Vycy5cbiAgICogTm90ZSB0aGF0IGlmIG5vIGZpbGVzIGFyZSByZWplY3RlZCwgdGhpcyBjYWxsYmFjayBpcyBub3QgaW52b2tlZC5cbiAgICpcbiAgICogQHBhcmFtIHtGaWxlUmVqZWN0aW9uW119IGZpbGVSZWplY3Rpb25zXG4gICAqIEBwYXJhbSB7KERyYWdFdmVudHxFdmVudCl9IGV2ZW50XG4gICAqL1xuICBvbkRyb3BSZWplY3RlZDogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIENiIGZvciB3aGVuIHRoZXJlJ3Mgc29tZSBlcnJvciBmcm9tIGFueSBvZiB0aGUgcHJvbWlzZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7RXJyb3J9IGVycm9yXG4gICAqL1xuICBvbkVycm9yOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQ3VzdG9tIHZhbGlkYXRpb24gZnVuY3Rpb24uIEl0IG11c3QgcmV0dXJuIG51bGwgaWYgdGhlcmUncyBubyBlcnJvcnMuXG4gICAqIEBwYXJhbSB7RmlsZX0gZmlsZVxuICAgKiBAcmV0dXJucyB7RmlsZUVycm9yfEZpbGVFcnJvcltdfG51bGx9XG4gICAqL1xuICB2YWxpZGF0b3I6IFByb3BUeXBlcy5mdW5jXG59O1xuZXhwb3J0IGRlZmF1bHQgRHJvcHpvbmU7XG4vKipcbiAqIEEgZnVuY3Rpb24gdGhhdCBpcyBpbnZva2VkIGZvciB0aGUgYGRyYWdlbnRlcmAsXG4gKiBgZHJhZ292ZXJgIGFuZCBgZHJhZ2xlYXZlYCBldmVudHMuXG4gKiBJdCBpcyBub3QgaW52b2tlZCBpZiB0aGUgaXRlbXMgYXJlIG5vdCBmaWxlcyAoc3VjaCBhcyBsaW5rLCB0ZXh0LCBldGMuKS5cbiAqXG4gKiBAY2FsbGJhY2sgZHJhZ0NiXG4gKiBAcGFyYW0ge0RyYWdFdmVudH0gZXZlbnRcbiAqL1xuXG4vKipcbiAqIEEgZnVuY3Rpb24gdGhhdCBpcyBpbnZva2VkIGZvciB0aGUgYGRyb3BgIG9yIGlucHV0IGNoYW5nZSBldmVudC5cbiAqIEl0IGlzIG5vdCBpbnZva2VkIGlmIHRoZSBpdGVtcyBhcmUgbm90IGZpbGVzIChzdWNoIGFzIGxpbmssIHRleHQsIGV0Yy4pLlxuICpcbiAqIEBjYWxsYmFjayBkcm9wQ2JcbiAqIEBwYXJhbSB7RmlsZVtdfSBhY2NlcHRlZEZpbGVzIExpc3Qgb2YgYWNjZXB0ZWQgZmlsZXNcbiAqIEBwYXJhbSB7RmlsZVJlamVjdGlvbltdfSBmaWxlUmVqZWN0aW9ucyBMaXN0IG9mIHJlamVjdGVkIGZpbGVzIGFuZCB3aHkgdGhleSB3ZXJlIHJlamVjdGVkXG4gKiBAcGFyYW0geyhEcmFnRXZlbnR8RXZlbnQpfSBldmVudCBBIGRyYWcgZXZlbnQgb3IgaW5wdXQgY2hhbmdlIGV2ZW50IChpZiBmaWxlcyB3ZXJlIHNlbGVjdGVkIHZpYSB0aGUgZmlsZSBkaWFsb2cpXG4gKi9cblxuLyoqXG4gKiBBIGZ1bmN0aW9uIHRoYXQgaXMgaW52b2tlZCBmb3IgdGhlIGBkcm9wYCBvciBpbnB1dCBjaGFuZ2UgZXZlbnQuXG4gKiBJdCBpcyBub3QgaW52b2tlZCBpZiB0aGUgaXRlbXMgYXJlIGZpbGVzIChzdWNoIGFzIGxpbmssIHRleHQsIGV0Yy4pLlxuICpcbiAqIEBjYWxsYmFjayBkcm9wQWNjZXB0ZWRDYlxuICogQHBhcmFtIHtGaWxlW119IGZpbGVzIExpc3Qgb2YgYWNjZXB0ZWQgZmlsZXMgdGhhdCBtZWV0IHRoZSBnaXZlbiBjcml0ZXJpYVxuICogKGBhY2NlcHRgLCBgbXVsdGlwbGVgLCBgbWluU2l6ZWAsIGBtYXhTaXplYClcbiAqIEBwYXJhbSB7KERyYWdFdmVudHxFdmVudCl9IGV2ZW50IEEgZHJhZyBldmVudCBvciBpbnB1dCBjaGFuZ2UgZXZlbnQgKGlmIGZpbGVzIHdlcmUgc2VsZWN0ZWQgdmlhIHRoZSBmaWxlIGRpYWxvZylcbiAqL1xuXG4vKipcbiAqIEEgZnVuY3Rpb24gdGhhdCBpcyBpbnZva2VkIGZvciB0aGUgYGRyb3BgIG9yIGlucHV0IGNoYW5nZSBldmVudC5cbiAqXG4gKiBAY2FsbGJhY2sgZHJvcFJlamVjdGVkQ2JcbiAqIEBwYXJhbSB7RmlsZVtdfSBmaWxlcyBMaXN0IG9mIHJlamVjdGVkIGZpbGVzIHRoYXQgZG8gbm90IG1lZXQgdGhlIGdpdmVuIGNyaXRlcmlhXG4gKiAoYGFjY2VwdGAsIGBtdWx0aXBsZWAsIGBtaW5TaXplYCwgYG1heFNpemVgKVxuICogQHBhcmFtIHsoRHJhZ0V2ZW50fEV2ZW50KX0gZXZlbnQgQSBkcmFnIGV2ZW50IG9yIGlucHV0IGNoYW5nZSBldmVudCAoaWYgZmlsZXMgd2VyZSBzZWxlY3RlZCB2aWEgdGhlIGZpbGUgZGlhbG9nKVxuICovXG5cbi8qKlxuICogQSBmdW5jdGlvbiB0aGF0IGlzIHVzZWQgYWdncmVnYXRlIGZpbGVzLFxuICogaW4gYSBhc3luY2hyb25vdXMgZmFzaGlvbiwgZnJvbSBkcmFnIG9yIGlucHV0IGNoYW5nZSBldmVudHMuXG4gKlxuICogQGNhbGxiYWNrIGdldEZpbGVzRnJvbUV2ZW50XG4gKiBAcGFyYW0geyhEcmFnRXZlbnR8RXZlbnQpfSBldmVudCBBIGRyYWcgZXZlbnQgb3IgaW5wdXQgY2hhbmdlIGV2ZW50IChpZiBmaWxlcyB3ZXJlIHNlbGVjdGVkIHZpYSB0aGUgZmlsZSBkaWFsb2cpXG4gKiBAcmV0dXJucyB7KEZpbGVbXXxQcm9taXNlPEZpbGVbXT4pfVxuICovXG5cbi8qKlxuICogQW4gb2JqZWN0IHdpdGggdGhlIGN1cnJlbnQgZHJvcHpvbmUgc3RhdGUuXG4gKlxuICogQHR5cGVkZWYge29iamVjdH0gRHJvcHpvbmVTdGF0ZVxuICogQHByb3BlcnR5IHtib29sZWFufSBpc0ZvY3VzZWQgRHJvcHpvbmUgYXJlYSBpcyBpbiBmb2N1c1xuICogQHByb3BlcnR5IHtib29sZWFufSBpc0ZpbGVEaWFsb2dBY3RpdmUgRmlsZSBkaWFsb2cgaXMgb3BlbmVkXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGlzRHJhZ0FjdGl2ZSBBY3RpdmUgZHJhZyBpcyBpbiBwcm9ncmVzc1xuICogQHByb3BlcnR5IHtib29sZWFufSBpc0RyYWdBY2NlcHQgRHJhZ2dlZCBmaWxlcyBhcmUgYWNjZXB0ZWRcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaXNEcmFnUmVqZWN0IFNvbWUgZHJhZ2dlZCBmaWxlcyBhcmUgcmVqZWN0ZWRcbiAqIEBwcm9wZXJ0eSB7RmlsZVtdfSBhY2NlcHRlZEZpbGVzIEFjY2VwdGVkIGZpbGVzXG4gKiBAcHJvcGVydHkge0ZpbGVSZWplY3Rpb25bXX0gZmlsZVJlamVjdGlvbnMgUmVqZWN0ZWQgZmlsZXMgYW5kIHdoeSB0aGV5IHdlcmUgcmVqZWN0ZWRcbiAqL1xuXG4vKipcbiAqIEFuIG9iamVjdCB3aXRoIHRoZSBkcm9wem9uZSBtZXRob2RzLlxuICpcbiAqIEB0eXBlZGVmIHtvYmplY3R9IERyb3B6b25lTWV0aG9kc1xuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gZ2V0Um9vdFByb3BzIFJldHVybnMgdGhlIHByb3BzIHlvdSBzaG91bGQgYXBwbHkgdG8gdGhlIHJvb3QgZHJvcCBjb250YWluZXIgeW91IHJlbmRlclxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gZ2V0SW5wdXRQcm9wcyBSZXR1cm5zIHRoZSBwcm9wcyB5b3Ugc2hvdWxkIGFwcGx5IHRvIGhpZGRlbiBmaWxlIGlucHV0IHlvdSByZW5kZXJcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IG9wZW4gT3BlbiB0aGUgbmF0aXZlIGZpbGUgc2VsZWN0aW9uIGRpYWxvZ1xuICovXG5cbnZhciBpbml0aWFsU3RhdGUgPSB7XG4gIGlzRm9jdXNlZDogZmFsc2UsXG4gIGlzRmlsZURpYWxvZ0FjdGl2ZTogZmFsc2UsXG4gIGlzRHJhZ0FjdGl2ZTogZmFsc2UsXG4gIGlzRHJhZ0FjY2VwdDogZmFsc2UsXG4gIGlzRHJhZ1JlamVjdDogZmFsc2UsXG4gIGFjY2VwdGVkRmlsZXM6IFtdLFxuICBmaWxlUmVqZWN0aW9uczogW11cbn07XG4vKipcbiAqIEEgUmVhY3QgaG9vayB0aGF0IGNyZWF0ZXMgYSBkcmFnICduJyBkcm9wIGFyZWEuXG4gKlxuICogYGBganN4XG4gKiBmdW5jdGlvbiBNeURyb3B6b25lKHByb3BzKSB7XG4gKiAgIGNvbnN0IHtnZXRSb290UHJvcHMsIGdldElucHV0UHJvcHN9ID0gdXNlRHJvcHpvbmUoe1xuICogICAgIG9uRHJvcDogYWNjZXB0ZWRGaWxlcyA9PiB7XG4gKiAgICAgICAvLyBkbyBzb21ldGhpbmcgd2l0aCB0aGUgRmlsZSBvYmplY3RzLCBlLmcuIHVwbG9hZCB0byBzb21lIHNlcnZlclxuICogICAgIH1cbiAqICAgfSk7XG4gKiAgIHJldHVybiAoXG4gKiAgICAgPGRpdiB7Li4uZ2V0Um9vdFByb3BzKCl9PlxuICogICAgICAgPGlucHV0IHsuLi5nZXRJbnB1dFByb3BzKCl9IC8+XG4gKiAgICAgICA8cD5EcmFnIGFuZCBkcm9wIHNvbWUgZmlsZXMgaGVyZSwgb3IgY2xpY2sgdG8gc2VsZWN0IGZpbGVzPC9wPlxuICogICAgIDwvZGl2PlxuICogICApXG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAZnVuY3Rpb24gdXNlRHJvcHpvbmVcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi91dGlsc1wiKS5BY2NlcHRQcm9wfSBbcHJvcHMuYWNjZXB0XSBTZXQgYWNjZXB0ZWQgZmlsZSB0eXBlcy5cbiAqIENoZWNrb3V0IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS93aW5kb3cvc2hvd09wZW5GaWxlUGlja2VyIHR5cGVzIG9wdGlvbiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqIEtlZXAgaW4gbWluZCB0aGF0IG1pbWUgdHlwZSBkZXRlcm1pbmF0aW9uIGlzIG5vdCByZWxpYWJsZSBhY3Jvc3MgcGxhdGZvcm1zLiBDU1YgZmlsZXMsXG4gKiBmb3IgZXhhbXBsZSwgYXJlIHJlcG9ydGVkIGFzIHRleHQvcGxhaW4gdW5kZXIgbWFjT1MgYnV0IGFzIGFwcGxpY2F0aW9uL3ZuZC5tcy1leGNlbCB1bmRlclxuICogV2luZG93cy4gSW4gc29tZSBjYXNlcyB0aGVyZSBtaWdodCBub3QgYmUgYSBtaW1lIHR5cGUgc2V0IGF0IGFsbCAoaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0LWRyb3B6b25lL3JlYWN0LWRyb3B6b25lL2lzc3Vlcy8yNzYpLlxuICogQHBhcmFtIHtib29sZWFufSBbcHJvcHMubXVsdGlwbGU9dHJ1ZV0gQWxsb3cgZHJhZyAnbicgZHJvcCAob3Igc2VsZWN0aW9uIGZyb20gdGhlIGZpbGUgZGlhbG9nKSBvZiBtdWx0aXBsZSBmaWxlc1xuICogQHBhcmFtIHtib29sZWFufSBbcHJvcHMucHJldmVudERyb3BPbkRvY3VtZW50PXRydWVdIElmIGZhbHNlLCBhbGxvdyBkcm9wcGVkIGl0ZW1zIHRvIHRha2Ugb3ZlciB0aGUgY3VycmVudCBicm93c2VyIHdpbmRvd1xuICogQHBhcmFtIHtib29sZWFufSBbcHJvcHMubm9DbGljaz1mYWxzZV0gSWYgdHJ1ZSwgZGlzYWJsZXMgY2xpY2sgdG8gb3BlbiB0aGUgbmF0aXZlIGZpbGUgc2VsZWN0aW9uIGRpYWxvZ1xuICogQHBhcmFtIHtib29sZWFufSBbcHJvcHMubm9LZXlib2FyZD1mYWxzZV0gSWYgdHJ1ZSwgZGlzYWJsZXMgU1BBQ0UvRU5URVIgdG8gb3BlbiB0aGUgbmF0aXZlIGZpbGUgc2VsZWN0aW9uIGRpYWxvZy5cbiAqIE5vdGUgdGhhdCBpdCBhbHNvIHN0b3BzIHRyYWNraW5nIHRoZSBmb2N1cyBzdGF0ZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Byb3BzLm5vRHJhZz1mYWxzZV0gSWYgdHJ1ZSwgZGlzYWJsZXMgZHJhZyAnbicgZHJvcFxuICogQHBhcmFtIHtib29sZWFufSBbcHJvcHMubm9EcmFnRXZlbnRzQnViYmxpbmc9ZmFsc2VdIElmIHRydWUsIHN0b3BzIGRyYWcgZXZlbnQgcHJvcGFnYXRpb24gdG8gcGFyZW50c1xuICogQHBhcmFtIHtudW1iZXJ9IFtwcm9wcy5taW5TaXplPTBdIE1pbmltdW0gZmlsZSBzaXplIChpbiBieXRlcylcbiAqIEBwYXJhbSB7bnVtYmVyfSBbcHJvcHMubWF4U2l6ZT1JbmZpbml0eV0gTWF4aW11bSBmaWxlIHNpemUgKGluIGJ5dGVzKVxuICogQHBhcmFtIHtib29sZWFufSBbcHJvcHMuZGlzYWJsZWQ9ZmFsc2VdIEVuYWJsZS9kaXNhYmxlIHRoZSBkcm9wem9uZVxuICogQHBhcmFtIHtnZXRGaWxlc0Zyb21FdmVudH0gW3Byb3BzLmdldEZpbGVzRnJvbUV2ZW50XSBVc2UgdGhpcyB0byBwcm92aWRlIGEgY3VzdG9tIGZpbGUgYWdncmVnYXRvclxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3Byb3BzLm9uRmlsZURpYWxvZ0NhbmNlbF0gQ2IgZm9yIHdoZW4gY2xvc2luZyB0aGUgZmlsZSBkaWFsb2cgd2l0aCBubyBzZWxlY3Rpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Byb3BzLnVzZUZzQWNjZXNzQXBpXSBTZXQgdG8gdHJ1ZSB0byB1c2UgdGhlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9GaWxlX1N5c3RlbV9BY2Nlc3NfQVBJXG4gKiB0byBvcGVuIHRoZSBmaWxlIHBpY2tlciBpbnN0ZWFkIG9mIHVzaW5nIGFuIGA8aW5wdXQgdHlwZT1cImZpbGVcIj5gIGNsaWNrIGV2ZW50LlxuICogQHBhcmFtIHtib29sZWFufSBhdXRvRm9jdXMgU2V0IHRvIHRydWUgdG8gYXV0byBmb2N1cyB0aGUgcm9vdCBlbGVtZW50LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3Byb3BzLm9uRmlsZURpYWxvZ09wZW5dIENiIGZvciB3aGVuIG9wZW5pbmcgdGhlIGZpbGUgZGlhbG9nXG4gKiBAcGFyYW0ge2RyYWdDYn0gW3Byb3BzLm9uRHJhZ0VudGVyXSBDYiBmb3Igd2hlbiB0aGUgYGRyYWdlbnRlcmAgZXZlbnQgb2NjdXJzLlxuICogQHBhcmFtIHtkcmFnQ2J9IFtwcm9wcy5vbkRyYWdMZWF2ZV0gQ2IgZm9yIHdoZW4gdGhlIGBkcmFnbGVhdmVgIGV2ZW50IG9jY3Vyc1xuICogQHBhcmFtIHtkcmFnQ2J9IFtwcm9wcy5vbkRyYWdPdmVyXSBDYiBmb3Igd2hlbiB0aGUgYGRyYWdvdmVyYCBldmVudCBvY2N1cnNcbiAqIEBwYXJhbSB7ZHJvcENifSBbcHJvcHMub25Ecm9wXSBDYiBmb3Igd2hlbiB0aGUgYGRyb3BgIGV2ZW50IG9jY3Vycy5cbiAqIE5vdGUgdGhhdCB0aGlzIGNhbGxiYWNrIGlzIGludm9rZWQgYWZ0ZXIgdGhlIGBnZXRGaWxlc0Zyb21FdmVudGAgY2FsbGJhY2sgaXMgZG9uZS5cbiAqXG4gKiBGaWxlcyBhcmUgYWNjZXB0ZWQgb3IgcmVqZWN0ZWQgYmFzZWQgb24gdGhlIGBhY2NlcHRgLCBgbXVsdGlwbGVgLCBgbWluU2l6ZWAgYW5kIGBtYXhTaXplYCBwcm9wcy5cbiAqIGBhY2NlcHRgIG11c3QgYmUgYW4gb2JqZWN0IHdpdGgga2V5cyBhcyBhIHZhbGlkIFtNSU1FIHR5cGVdKGh0dHA6Ly93d3cuaWFuYS5vcmcvYXNzaWdubWVudHMvbWVkaWEtdHlwZXMvbWVkaWEtdHlwZXMueGh0bWwpIGFjY29yZGluZyB0byBbaW5wdXQgZWxlbWVudCBzcGVjaWZpY2F0aW9uXShodHRwczovL3d3dy53My5vcmcvd2lraS9IVE1ML0VsZW1lbnRzL2lucHV0L2ZpbGUpIGFuZCB0aGUgdmFsdWUgYW4gYXJyYXkgb2YgZmlsZSBleHRlbnNpb25zIChvcHRpb25hbCkuXG4gKiBJZiBgbXVsdGlwbGVgIGlzIHNldCB0byBmYWxzZSBhbmQgYWRkaXRpb25hbCBmaWxlcyBhcmUgZHJvcHBlZCxcbiAqIGFsbCBmaWxlcyBiZXNpZGVzIHRoZSBmaXJzdCB3aWxsIGJlIHJlamVjdGVkLlxuICogQW55IGZpbGUgd2hpY2ggZG9lcyBub3QgaGF2ZSBhIHNpemUgaW4gdGhlIFtgbWluU2l6ZWAsIGBtYXhTaXplYF0gcmFuZ2UsIHdpbGwgYmUgcmVqZWN0ZWQgYXMgd2VsbC5cbiAqXG4gKiBOb3RlIHRoYXQgdGhlIGBvbkRyb3BgIGNhbGxiYWNrIHdpbGwgYWx3YXlzIGJlIGludm9rZWQgcmVnYXJkbGVzcyBpZiB0aGUgZHJvcHBlZCBmaWxlcyB3ZXJlIGFjY2VwdGVkIG9yIHJlamVjdGVkLlxuICogSWYgeW91J2QgbGlrZSB0byByZWFjdCB0byBhIHNwZWNpZmljIHNjZW5hcmlvLCB1c2UgdGhlIGBvbkRyb3BBY2NlcHRlZGAvYG9uRHJvcFJlamVjdGVkYCBwcm9wcy5cbiAqXG4gKiBgb25Ecm9wYCB3aWxsIHByb3ZpZGUgeW91IHdpdGggYW4gYXJyYXkgb2YgW0ZpbGVdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9GaWxlKSBvYmplY3RzIHdoaWNoIHlvdSBjYW4gdGhlbiBwcm9jZXNzIGFuZCBzZW5kIHRvIGEgc2VydmVyLlxuICogRm9yIGV4YW1wbGUsIHdpdGggW1N1cGVyQWdlbnRdKGh0dHBzOi8vZ2l0aHViLmNvbS92aXNpb25tZWRpYS9zdXBlcmFnZW50KSBhcyBhIGh0dHAvYWpheCBsaWJyYXJ5OlxuICpcbiAqIGBgYGpzXG4gKiBmdW5jdGlvbiBvbkRyb3AoYWNjZXB0ZWRGaWxlcykge1xuICogICBjb25zdCByZXEgPSByZXF1ZXN0LnBvc3QoJy91cGxvYWQnKVxuICogICBhY2NlcHRlZEZpbGVzLmZvckVhY2goZmlsZSA9PiB7XG4gKiAgICAgcmVxLmF0dGFjaChmaWxlLm5hbWUsIGZpbGUpXG4gKiAgIH0pXG4gKiAgIHJlcS5lbmQoY2FsbGJhY2spXG4gKiB9XG4gKiBgYGBcbiAqIEBwYXJhbSB7ZHJvcEFjY2VwdGVkQ2J9IFtwcm9wcy5vbkRyb3BBY2NlcHRlZF1cbiAqIEBwYXJhbSB7ZHJvcFJlamVjdGVkQ2J9IFtwcm9wcy5vbkRyb3BSZWplY3RlZF1cbiAqIEBwYXJhbSB7KGVycm9yOiBFcnJvcikgPT4gdm9pZH0gW3Byb3BzLm9uRXJyb3JdXG4gKlxuICogQHJldHVybnMge0Ryb3B6b25lU3RhdGUgJiBEcm9wem9uZU1ldGhvZHN9XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZURyb3B6b25lKCkge1xuICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gIHZhciBfZGVmYXVsdFByb3BzJHByb3BzID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBkZWZhdWx0UHJvcHMpLCBwcm9wcyksXG4gICAgICBhY2NlcHQgPSBfZGVmYXVsdFByb3BzJHByb3BzLmFjY2VwdCxcbiAgICAgIGRpc2FibGVkID0gX2RlZmF1bHRQcm9wcyRwcm9wcy5kaXNhYmxlZCxcbiAgICAgIGdldEZpbGVzRnJvbUV2ZW50ID0gX2RlZmF1bHRQcm9wcyRwcm9wcy5nZXRGaWxlc0Zyb21FdmVudCxcbiAgICAgIG1heFNpemUgPSBfZGVmYXVsdFByb3BzJHByb3BzLm1heFNpemUsXG4gICAgICBtaW5TaXplID0gX2RlZmF1bHRQcm9wcyRwcm9wcy5taW5TaXplLFxuICAgICAgbXVsdGlwbGUgPSBfZGVmYXVsdFByb3BzJHByb3BzLm11bHRpcGxlLFxuICAgICAgbWF4RmlsZXMgPSBfZGVmYXVsdFByb3BzJHByb3BzLm1heEZpbGVzLFxuICAgICAgb25EcmFnRW50ZXIgPSBfZGVmYXVsdFByb3BzJHByb3BzLm9uRHJhZ0VudGVyLFxuICAgICAgb25EcmFnTGVhdmUgPSBfZGVmYXVsdFByb3BzJHByb3BzLm9uRHJhZ0xlYXZlLFxuICAgICAgb25EcmFnT3ZlciA9IF9kZWZhdWx0UHJvcHMkcHJvcHMub25EcmFnT3ZlcixcbiAgICAgIG9uRHJvcCA9IF9kZWZhdWx0UHJvcHMkcHJvcHMub25Ecm9wLFxuICAgICAgb25Ecm9wQWNjZXB0ZWQgPSBfZGVmYXVsdFByb3BzJHByb3BzLm9uRHJvcEFjY2VwdGVkLFxuICAgICAgb25Ecm9wUmVqZWN0ZWQgPSBfZGVmYXVsdFByb3BzJHByb3BzLm9uRHJvcFJlamVjdGVkLFxuICAgICAgb25GaWxlRGlhbG9nQ2FuY2VsID0gX2RlZmF1bHRQcm9wcyRwcm9wcy5vbkZpbGVEaWFsb2dDYW5jZWwsXG4gICAgICBvbkZpbGVEaWFsb2dPcGVuID0gX2RlZmF1bHRQcm9wcyRwcm9wcy5vbkZpbGVEaWFsb2dPcGVuLFxuICAgICAgdXNlRnNBY2Nlc3NBcGkgPSBfZGVmYXVsdFByb3BzJHByb3BzLnVzZUZzQWNjZXNzQXBpLFxuICAgICAgYXV0b0ZvY3VzID0gX2RlZmF1bHRQcm9wcyRwcm9wcy5hdXRvRm9jdXMsXG4gICAgICBwcmV2ZW50RHJvcE9uRG9jdW1lbnQgPSBfZGVmYXVsdFByb3BzJHByb3BzLnByZXZlbnREcm9wT25Eb2N1bWVudCxcbiAgICAgIG5vQ2xpY2sgPSBfZGVmYXVsdFByb3BzJHByb3BzLm5vQ2xpY2ssXG4gICAgICBub0tleWJvYXJkID0gX2RlZmF1bHRQcm9wcyRwcm9wcy5ub0tleWJvYXJkLFxuICAgICAgbm9EcmFnID0gX2RlZmF1bHRQcm9wcyRwcm9wcy5ub0RyYWcsXG4gICAgICBub0RyYWdFdmVudHNCdWJibGluZyA9IF9kZWZhdWx0UHJvcHMkcHJvcHMubm9EcmFnRXZlbnRzQnViYmxpbmcsXG4gICAgICBvbkVycm9yID0gX2RlZmF1bHRQcm9wcyRwcm9wcy5vbkVycm9yLFxuICAgICAgdmFsaWRhdG9yID0gX2RlZmF1bHRQcm9wcyRwcm9wcy52YWxpZGF0b3I7XG5cbiAgdmFyIGFjY2VwdEF0dHIgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYWNjZXB0UHJvcEFzQWNjZXB0QXR0cihhY2NlcHQpO1xuICB9LCBbYWNjZXB0XSk7XG4gIHZhciBwaWNrZXJUeXBlcyA9IHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBwaWNrZXJPcHRpb25zRnJvbUFjY2VwdChhY2NlcHQpO1xuICB9LCBbYWNjZXB0XSk7XG4gIHZhciBvbkZpbGVEaWFsb2dPcGVuQ2IgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdHlwZW9mIG9uRmlsZURpYWxvZ09wZW4gPT09IFwiZnVuY3Rpb25cIiA/IG9uRmlsZURpYWxvZ09wZW4gOiBub29wO1xuICB9LCBbb25GaWxlRGlhbG9nT3Blbl0pO1xuICB2YXIgb25GaWxlRGlhbG9nQ2FuY2VsQ2IgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdHlwZW9mIG9uRmlsZURpYWxvZ0NhbmNlbCA9PT0gXCJmdW5jdGlvblwiID8gb25GaWxlRGlhbG9nQ2FuY2VsIDogbm9vcDtcbiAgfSwgW29uRmlsZURpYWxvZ0NhbmNlbF0pO1xuICAvKipcbiAgICogQGNvbnN0YW50XG4gICAqIEB0eXBlIHtSZWFjdC5NdXRhYmxlUmVmT2JqZWN0PEhUTUxFbGVtZW50Pn1cbiAgICovXG5cbiAgdmFyIHJvb3RSZWYgPSB1c2VSZWYobnVsbCk7XG4gIHZhciBpbnB1dFJlZiA9IHVzZVJlZihudWxsKTtcblxuICB2YXIgX3VzZVJlZHVjZXIgPSB1c2VSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxTdGF0ZSksXG4gICAgICBfdXNlUmVkdWNlcjIgPSBfc2xpY2VkVG9BcnJheShfdXNlUmVkdWNlciwgMiksXG4gICAgICBzdGF0ZSA9IF91c2VSZWR1Y2VyMlswXSxcbiAgICAgIGRpc3BhdGNoID0gX3VzZVJlZHVjZXIyWzFdO1xuXG4gIHZhciBpc0ZvY3VzZWQgPSBzdGF0ZS5pc0ZvY3VzZWQsXG4gICAgICBpc0ZpbGVEaWFsb2dBY3RpdmUgPSBzdGF0ZS5pc0ZpbGVEaWFsb2dBY3RpdmU7XG4gIHZhciBmc0FjY2Vzc0FwaVdvcmtzUmVmID0gdXNlUmVmKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LmlzU2VjdXJlQ29udGV4dCAmJiB1c2VGc0FjY2Vzc0FwaSAmJiBjYW5Vc2VGaWxlU3lzdGVtQWNjZXNzQVBJKCkpOyAvLyBVcGRhdGUgZmlsZSBkaWFsb2cgYWN0aXZlIHN0YXRlIHdoZW4gdGhlIHdpbmRvdyBpcyBmb2N1c2VkIG9uXG5cbiAgdmFyIG9uV2luZG93Rm9jdXMgPSBmdW5jdGlvbiBvbldpbmRvd0ZvY3VzKCkge1xuICAgIC8vIEV4ZWN1dGUgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgZmlsZSBkaWFsb2cgaXMgb3BlbmVkIGluIHRoZSBicm93c2VyXG4gICAgaWYgKCFmc0FjY2Vzc0FwaVdvcmtzUmVmLmN1cnJlbnQgJiYgaXNGaWxlRGlhbG9nQWN0aXZlKSB7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGlucHV0UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICB2YXIgZmlsZXMgPSBpbnB1dFJlZi5jdXJyZW50LmZpbGVzO1xuXG4gICAgICAgICAgaWYgKCFmaWxlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJjbG9zZURpYWxvZ1wiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG9uRmlsZURpYWxvZ0NhbmNlbENiKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCAzMDApO1xuICAgIH1cbiAgfTtcblxuICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgb25XaW5kb3dGb2N1cywgZmFsc2UpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIG9uV2luZG93Rm9jdXMsIGZhbHNlKTtcbiAgICB9O1xuICB9LCBbaW5wdXRSZWYsIGlzRmlsZURpYWxvZ0FjdGl2ZSwgb25GaWxlRGlhbG9nQ2FuY2VsQ2IsIGZzQWNjZXNzQXBpV29ya3NSZWZdKTtcbiAgdmFyIGRyYWdUYXJnZXRzUmVmID0gdXNlUmVmKFtdKTtcblxuICB2YXIgb25Eb2N1bWVudERyb3AgPSBmdW5jdGlvbiBvbkRvY3VtZW50RHJvcChldmVudCkge1xuICAgIGlmIChyb290UmVmLmN1cnJlbnQgJiYgcm9vdFJlZi5jdXJyZW50LmNvbnRhaW5zKGV2ZW50LnRhcmdldCkpIHtcbiAgICAgIC8vIElmIHdlIGludGVyY2VwdGVkIGFuIGV2ZW50IGZvciBvdXIgaW5zdGFuY2UsIGxldCBpdCBwcm9wYWdhdGUgZG93biB0byB0aGUgaW5zdGFuY2UncyBvbkRyb3AgaGFuZGxlclxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgZHJhZ1RhcmdldHNSZWYuY3VycmVudCA9IFtdO1xuICB9O1xuXG4gIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHByZXZlbnREcm9wT25Eb2N1bWVudCkge1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImRyYWdvdmVyXCIsIG9uRG9jdW1lbnREcmFnT3ZlciwgZmFsc2UpO1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImRyb3BcIiwgb25Eb2N1bWVudERyb3AsIGZhbHNlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHByZXZlbnREcm9wT25Eb2N1bWVudCkge1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZHJhZ292ZXJcIiwgb25Eb2N1bWVudERyYWdPdmVyKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImRyb3BcIiwgb25Eb2N1bWVudERyb3ApO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtyb290UmVmLCBwcmV2ZW50RHJvcE9uRG9jdW1lbnRdKTsgLy8gQXV0byBmb2N1cyB0aGUgcm9vdCB3aGVuIGF1dG9Gb2N1cyBpcyB0cnVlXG5cbiAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIWRpc2FibGVkICYmIGF1dG9Gb2N1cyAmJiByb290UmVmLmN1cnJlbnQpIHtcbiAgICAgIHJvb3RSZWYuY3VycmVudC5mb2N1cygpO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7fTtcbiAgfSwgW3Jvb3RSZWYsIGF1dG9Gb2N1cywgZGlzYWJsZWRdKTtcbiAgdmFyIG9uRXJyQ2IgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoZSkge1xuICAgIGlmIChvbkVycm9yKSB7XG4gICAgICBvbkVycm9yKGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBMZXQgdGhlIHVzZXIga25vdyBzb21ldGhpbmcncyBnb25lIHdyb25nIGlmIHRoZXkgaGF2ZW4ndCBwcm92aWRlZCB0aGUgb25FcnJvciBjYi5cbiAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgfVxuICB9LCBbb25FcnJvcl0pO1xuICB2YXIgb25EcmFnRW50ZXJDYiA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIChldmVudCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IC8vIFBlcnNpc3QgaGVyZSBiZWNhdXNlIHdlIG5lZWQgdGhlIGV2ZW50IGxhdGVyIGFmdGVyIGdldEZpbGVzRnJvbUV2ZW50KCkgaXMgZG9uZVxuXG4gICAgZXZlbnQucGVyc2lzdCgpO1xuICAgIHN0b3BQcm9wYWdhdGlvbihldmVudCk7XG4gICAgZHJhZ1RhcmdldHNSZWYuY3VycmVudCA9IFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoZHJhZ1RhcmdldHNSZWYuY3VycmVudCksIFtldmVudC50YXJnZXRdKTtcblxuICAgIGlmIChpc0V2dFdpdGhGaWxlcyhldmVudCkpIHtcbiAgICAgIFByb21pc2UucmVzb2x2ZShnZXRGaWxlc0Zyb21FdmVudChldmVudCkpLnRoZW4oZnVuY3Rpb24gKGZpbGVzKSB7XG4gICAgICAgIGlmIChpc1Byb3BhZ2F0aW9uU3RvcHBlZChldmVudCkgJiYgIW5vRHJhZ0V2ZW50c0J1YmJsaW5nKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZpbGVDb3VudCA9IGZpbGVzLmxlbmd0aDtcbiAgICAgICAgdmFyIGlzRHJhZ0FjY2VwdCA9IGZpbGVDb3VudCA+IDAgJiYgYWxsRmlsZXNBY2NlcHRlZCh7XG4gICAgICAgICAgZmlsZXM6IGZpbGVzLFxuICAgICAgICAgIGFjY2VwdDogYWNjZXB0QXR0cixcbiAgICAgICAgICBtaW5TaXplOiBtaW5TaXplLFxuICAgICAgICAgIG1heFNpemU6IG1heFNpemUsXG4gICAgICAgICAgbXVsdGlwbGU6IG11bHRpcGxlLFxuICAgICAgICAgIG1heEZpbGVzOiBtYXhGaWxlcyxcbiAgICAgICAgICB2YWxpZGF0b3I6IHZhbGlkYXRvclxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGlzRHJhZ1JlamVjdCA9IGZpbGVDb3VudCA+IDAgJiYgIWlzRHJhZ0FjY2VwdDtcbiAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgIGlzRHJhZ0FjY2VwdDogaXNEcmFnQWNjZXB0LFxuICAgICAgICAgIGlzRHJhZ1JlamVjdDogaXNEcmFnUmVqZWN0LFxuICAgICAgICAgIGlzRHJhZ0FjdGl2ZTogdHJ1ZSxcbiAgICAgICAgICB0eXBlOiBcInNldERyYWdnZWRGaWxlc1wiXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChvbkRyYWdFbnRlcikge1xuICAgICAgICAgIG9uRHJhZ0VudGVyKGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIG9uRXJyQ2IoZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIFtnZXRGaWxlc0Zyb21FdmVudCwgb25EcmFnRW50ZXIsIG9uRXJyQ2IsIG5vRHJhZ0V2ZW50c0J1YmJsaW5nLCBhY2NlcHRBdHRyLCBtaW5TaXplLCBtYXhTaXplLCBtdWx0aXBsZSwgbWF4RmlsZXMsIHZhbGlkYXRvcl0pO1xuICB2YXIgb25EcmFnT3ZlckNiID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBldmVudC5wZXJzaXN0KCk7XG4gICAgc3RvcFByb3BhZ2F0aW9uKGV2ZW50KTtcbiAgICB2YXIgaGFzRmlsZXMgPSBpc0V2dFdpdGhGaWxlcyhldmVudCk7XG5cbiAgICBpZiAoaGFzRmlsZXMgJiYgZXZlbnQuZGF0YVRyYW5zZmVyKSB7XG4gICAgICB0cnkge1xuICAgICAgICBldmVudC5kYXRhVHJhbnNmZXIuZHJvcEVmZmVjdCA9IFwiY29weVwiO1xuICAgICAgfSBjYXRjaCAoX3VudXNlZCkge31cbiAgICAgIC8qIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZW1wdHkgKi9cblxuICAgIH1cblxuICAgIGlmIChoYXNGaWxlcyAmJiBvbkRyYWdPdmVyKSB7XG4gICAgICBvbkRyYWdPdmVyKGV2ZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sIFtvbkRyYWdPdmVyLCBub0RyYWdFdmVudHNCdWJibGluZ10pO1xuICB2YXIgb25EcmFnTGVhdmVDYiA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIChldmVudCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgZXZlbnQucGVyc2lzdCgpO1xuICAgIHN0b3BQcm9wYWdhdGlvbihldmVudCk7IC8vIE9ubHkgZGVhY3RpdmF0ZSBvbmNlIHRoZSBkcm9wem9uZSBhbmQgYWxsIGNoaWxkcmVuIGhhdmUgYmVlbiBsZWZ0XG5cbiAgICB2YXIgdGFyZ2V0cyA9IGRyYWdUYXJnZXRzUmVmLmN1cnJlbnQuZmlsdGVyKGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgIHJldHVybiByb290UmVmLmN1cnJlbnQgJiYgcm9vdFJlZi5jdXJyZW50LmNvbnRhaW5zKHRhcmdldCk7XG4gICAgfSk7IC8vIE1ha2Ugc3VyZSB0byByZW1vdmUgYSB0YXJnZXQgcHJlc2VudCBtdWx0aXBsZSB0aW1lcyBvbmx5IG9uY2VcbiAgICAvLyAoRmlyZWZveCBtYXkgZmlyZSBkcmFnZW50ZXIvZHJhZ2xlYXZlIG11bHRpcGxlIHRpbWVzIG9uIHRoZSBzYW1lIGVsZW1lbnQpXG5cbiAgICB2YXIgdGFyZ2V0SWR4ID0gdGFyZ2V0cy5pbmRleE9mKGV2ZW50LnRhcmdldCk7XG5cbiAgICBpZiAodGFyZ2V0SWR4ICE9PSAtMSkge1xuICAgICAgdGFyZ2V0cy5zcGxpY2UodGFyZ2V0SWR4LCAxKTtcbiAgICB9XG5cbiAgICBkcmFnVGFyZ2V0c1JlZi5jdXJyZW50ID0gdGFyZ2V0cztcblxuICAgIGlmICh0YXJnZXRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBkaXNwYXRjaCh7XG4gICAgICB0eXBlOiBcInNldERyYWdnZWRGaWxlc1wiLFxuICAgICAgaXNEcmFnQWN0aXZlOiBmYWxzZSxcbiAgICAgIGlzRHJhZ0FjY2VwdDogZmFsc2UsXG4gICAgICBpc0RyYWdSZWplY3Q6IGZhbHNlXG4gICAgfSk7XG5cbiAgICBpZiAoaXNFdnRXaXRoRmlsZXMoZXZlbnQpICYmIG9uRHJhZ0xlYXZlKSB7XG4gICAgICBvbkRyYWdMZWF2ZShldmVudCk7XG4gICAgfVxuICB9LCBbcm9vdFJlZiwgb25EcmFnTGVhdmUsIG5vRHJhZ0V2ZW50c0J1YmJsaW5nXSk7XG4gIHZhciBzZXRGaWxlcyA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIChmaWxlcywgZXZlbnQpIHtcbiAgICB2YXIgYWNjZXB0ZWRGaWxlcyA9IFtdO1xuICAgIHZhciBmaWxlUmVqZWN0aW9ucyA9IFtdO1xuICAgIGZpbGVzLmZvckVhY2goZnVuY3Rpb24gKGZpbGUpIHtcbiAgICAgIHZhciBfZmlsZUFjY2VwdGVkID0gZmlsZUFjY2VwdGVkKGZpbGUsIGFjY2VwdEF0dHIpLFxuICAgICAgICAgIF9maWxlQWNjZXB0ZWQyID0gX3NsaWNlZFRvQXJyYXkoX2ZpbGVBY2NlcHRlZCwgMiksXG4gICAgICAgICAgYWNjZXB0ZWQgPSBfZmlsZUFjY2VwdGVkMlswXSxcbiAgICAgICAgICBhY2NlcHRFcnJvciA9IF9maWxlQWNjZXB0ZWQyWzFdO1xuXG4gICAgICB2YXIgX2ZpbGVNYXRjaFNpemUgPSBmaWxlTWF0Y2hTaXplKGZpbGUsIG1pblNpemUsIG1heFNpemUpLFxuICAgICAgICAgIF9maWxlTWF0Y2hTaXplMiA9IF9zbGljZWRUb0FycmF5KF9maWxlTWF0Y2hTaXplLCAyKSxcbiAgICAgICAgICBzaXplTWF0Y2ggPSBfZmlsZU1hdGNoU2l6ZTJbMF0sXG4gICAgICAgICAgc2l6ZUVycm9yID0gX2ZpbGVNYXRjaFNpemUyWzFdO1xuXG4gICAgICB2YXIgY3VzdG9tRXJyb3JzID0gdmFsaWRhdG9yID8gdmFsaWRhdG9yKGZpbGUpIDogbnVsbDtcblxuICAgICAgaWYgKGFjY2VwdGVkICYmIHNpemVNYXRjaCAmJiAhY3VzdG9tRXJyb3JzKSB7XG4gICAgICAgIGFjY2VwdGVkRmlsZXMucHVzaChmaWxlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBlcnJvcnMgPSBbYWNjZXB0RXJyb3IsIHNpemVFcnJvcl07XG5cbiAgICAgICAgaWYgKGN1c3RvbUVycm9ycykge1xuICAgICAgICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQoY3VzdG9tRXJyb3JzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZpbGVSZWplY3Rpb25zLnB1c2goe1xuICAgICAgICAgIGZpbGU6IGZpbGUsXG4gICAgICAgICAgZXJyb3JzOiBlcnJvcnMuZmlsdGVyKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgICB9KVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmICghbXVsdGlwbGUgJiYgYWNjZXB0ZWRGaWxlcy5sZW5ndGggPiAxIHx8IG11bHRpcGxlICYmIG1heEZpbGVzID49IDEgJiYgYWNjZXB0ZWRGaWxlcy5sZW5ndGggPiBtYXhGaWxlcykge1xuICAgICAgLy8gUmVqZWN0IGV2ZXJ5dGhpbmcgYW5kIGVtcHR5IGFjY2VwdGVkIGZpbGVzXG4gICAgICBhY2NlcHRlZEZpbGVzLmZvckVhY2goZnVuY3Rpb24gKGZpbGUpIHtcbiAgICAgICAgZmlsZVJlamVjdGlvbnMucHVzaCh7XG4gICAgICAgICAgZmlsZTogZmlsZSxcbiAgICAgICAgICBlcnJvcnM6IFtUT09fTUFOWV9GSUxFU19SRUpFQ1RJT05dXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBhY2NlcHRlZEZpbGVzLnNwbGljZSgwKTtcbiAgICB9XG5cbiAgICBkaXNwYXRjaCh7XG4gICAgICBhY2NlcHRlZEZpbGVzOiBhY2NlcHRlZEZpbGVzLFxuICAgICAgZmlsZVJlamVjdGlvbnM6IGZpbGVSZWplY3Rpb25zLFxuICAgICAgaXNEcmFnUmVqZWN0OiBmaWxlUmVqZWN0aW9ucy5sZW5ndGggPiAwLFxuICAgICAgdHlwZTogXCJzZXRGaWxlc1wiXG4gICAgfSk7XG5cbiAgICBpZiAob25Ecm9wKSB7XG4gICAgICBvbkRyb3AoYWNjZXB0ZWRGaWxlcywgZmlsZVJlamVjdGlvbnMsIGV2ZW50KTtcbiAgICB9XG5cbiAgICBpZiAoZmlsZVJlamVjdGlvbnMubGVuZ3RoID4gMCAmJiBvbkRyb3BSZWplY3RlZCkge1xuICAgICAgb25Ecm9wUmVqZWN0ZWQoZmlsZVJlamVjdGlvbnMsIGV2ZW50KTtcbiAgICB9XG5cbiAgICBpZiAoYWNjZXB0ZWRGaWxlcy5sZW5ndGggPiAwICYmIG9uRHJvcEFjY2VwdGVkKSB7XG4gICAgICBvbkRyb3BBY2NlcHRlZChhY2NlcHRlZEZpbGVzLCBldmVudCk7XG4gICAgfVxuICB9LCBbZGlzcGF0Y2gsIG11bHRpcGxlLCBhY2NlcHRBdHRyLCBtaW5TaXplLCBtYXhTaXplLCBtYXhGaWxlcywgb25Ecm9wLCBvbkRyb3BBY2NlcHRlZCwgb25Ecm9wUmVqZWN0ZWQsIHZhbGlkYXRvcl0pO1xuICB2YXIgb25Ecm9wQ2IgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpOyAvLyBQZXJzaXN0IGhlcmUgYmVjYXVzZSB3ZSBuZWVkIHRoZSBldmVudCBsYXRlciBhZnRlciBnZXRGaWxlc0Zyb21FdmVudCgpIGlzIGRvbmVcblxuICAgIGV2ZW50LnBlcnNpc3QoKTtcbiAgICBzdG9wUHJvcGFnYXRpb24oZXZlbnQpO1xuICAgIGRyYWdUYXJnZXRzUmVmLmN1cnJlbnQgPSBbXTtcblxuICAgIGlmIChpc0V2dFdpdGhGaWxlcyhldmVudCkpIHtcbiAgICAgIFByb21pc2UucmVzb2x2ZShnZXRGaWxlc0Zyb21FdmVudChldmVudCkpLnRoZW4oZnVuY3Rpb24gKGZpbGVzKSB7XG4gICAgICAgIGlmIChpc1Byb3BhZ2F0aW9uU3RvcHBlZChldmVudCkgJiYgIW5vRHJhZ0V2ZW50c0J1YmJsaW5nKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0RmlsZXMoZmlsZXMsIGV2ZW50KTtcbiAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiBvbkVyckNiKGUpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZGlzcGF0Y2goe1xuICAgICAgdHlwZTogXCJyZXNldFwiXG4gICAgfSk7XG4gIH0sIFtnZXRGaWxlc0Zyb21FdmVudCwgc2V0RmlsZXMsIG9uRXJyQ2IsIG5vRHJhZ0V2ZW50c0J1YmJsaW5nXSk7IC8vIEZuIGZvciBvcGVuaW5nIHRoZSBmaWxlIGRpYWxvZyBwcm9ncmFtbWF0aWNhbGx5XG5cbiAgdmFyIG9wZW5GaWxlRGlhbG9nID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIC8vIE5vIHBvaW50IHRvIHVzZSBGUyBhY2Nlc3MgQVBJcyBpZiBjb250ZXh0IGlzIG5vdCBzZWN1cmVcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9TZWN1cml0eS9TZWN1cmVfQ29udGV4dHMjZmVhdHVyZV9kZXRlY3Rpb25cbiAgICBpZiAoZnNBY2Nlc3NBcGlXb3Jrc1JlZi5jdXJyZW50KSB7XG4gICAgICBkaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6IFwib3BlbkRpYWxvZ1wiXG4gICAgICB9KTtcbiAgICAgIG9uRmlsZURpYWxvZ09wZW5DYigpOyAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvd2luZG93L3Nob3dPcGVuRmlsZVBpY2tlclxuXG4gICAgICB2YXIgb3B0cyA9IHtcbiAgICAgICAgbXVsdGlwbGU6IG11bHRpcGxlLFxuICAgICAgICB0eXBlczogcGlja2VyVHlwZXNcbiAgICAgIH07XG4gICAgICB3aW5kb3cuc2hvd09wZW5GaWxlUGlja2VyKG9wdHMpLnRoZW4oZnVuY3Rpb24gKGhhbmRsZXMpIHtcbiAgICAgICAgcmV0dXJuIGdldEZpbGVzRnJvbUV2ZW50KGhhbmRsZXMpO1xuICAgICAgfSkudGhlbihmdW5jdGlvbiAoZmlsZXMpIHtcbiAgICAgICAgc2V0RmlsZXMoZmlsZXMsIG51bGwpO1xuICAgICAgICBkaXNwYXRjaCh7XG4gICAgICAgICAgdHlwZTogXCJjbG9zZURpYWxvZ1wiXG4gICAgICAgIH0pO1xuICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgLy8gQWJvcnRFcnJvciBtZWFucyB0aGUgdXNlciBjYW5jZWxlZFxuICAgICAgICBpZiAoaXNBYm9ydChlKSkge1xuICAgICAgICAgIG9uRmlsZURpYWxvZ0NhbmNlbENiKGUpO1xuICAgICAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6IFwiY2xvc2VEaWFsb2dcIlxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKGlzU2VjdXJpdHlFcnJvcihlKSkge1xuICAgICAgICAgIGZzQWNjZXNzQXBpV29ya3NSZWYuY3VycmVudCA9IGZhbHNlOyAvLyBDT1JTLCBzbyBjYW5ub3QgdXNlIHRoaXMgQVBJXG4gICAgICAgICAgLy8gVHJ5IHVzaW5nIHRoZSBpbnB1dFxuXG4gICAgICAgICAgaWYgKGlucHV0UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGlucHV0UmVmLmN1cnJlbnQudmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgaW5wdXRSZWYuY3VycmVudC5jbGljaygpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvbkVyckNiKG5ldyBFcnJvcihcIkNhbm5vdCBvcGVuIHRoZSBmaWxlIHBpY2tlciBiZWNhdXNlIHRoZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRmlsZV9TeXN0ZW1fQWNjZXNzX0FQSSBpcyBub3Qgc3VwcG9ydGVkIGFuZCBubyA8aW5wdXQ+IHdhcyBwcm92aWRlZC5cIikpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvbkVyckNiKGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaW5wdXRSZWYuY3VycmVudCkge1xuICAgICAgZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiBcIm9wZW5EaWFsb2dcIlxuICAgICAgfSk7XG4gICAgICBvbkZpbGVEaWFsb2dPcGVuQ2IoKTtcbiAgICAgIGlucHV0UmVmLmN1cnJlbnQudmFsdWUgPSBudWxsO1xuICAgICAgaW5wdXRSZWYuY3VycmVudC5jbGljaygpO1xuICAgIH1cbiAgfSwgW2Rpc3BhdGNoLCBvbkZpbGVEaWFsb2dPcGVuQ2IsIG9uRmlsZURpYWxvZ0NhbmNlbENiLCB1c2VGc0FjY2Vzc0FwaSwgc2V0RmlsZXMsIG9uRXJyQ2IsIHBpY2tlclR5cGVzLCBtdWx0aXBsZV0pOyAvLyBDYiB0byBvcGVuIHRoZSBmaWxlIGRpYWxvZyB3aGVuIFNQQUNFL0VOVEVSIG9jY3VycyBvbiB0aGUgZHJvcHpvbmVcblxuICB2YXIgb25LZXlEb3duQ2IgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBJZ25vcmUga2V5Ym9hcmQgZXZlbnRzIGJ1YmJsaW5nIHVwIHRoZSBET00gdHJlZVxuICAgIGlmICghcm9vdFJlZi5jdXJyZW50IHx8ICFyb290UmVmLmN1cnJlbnQuaXNFcXVhbE5vZGUoZXZlbnQudGFyZ2V0KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChldmVudC5rZXkgPT09IFwiIFwiIHx8IGV2ZW50LmtleSA9PT0gXCJFbnRlclwiIHx8IGV2ZW50LmtleUNvZGUgPT09IDMyIHx8IGV2ZW50LmtleUNvZGUgPT09IDEzKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgb3BlbkZpbGVEaWFsb2coKTtcbiAgICB9XG4gIH0sIFtyb290UmVmLCBvcGVuRmlsZURpYWxvZ10pOyAvLyBVcGRhdGUgZm9jdXMgc3RhdGUgZm9yIHRoZSBkcm9wem9uZVxuXG4gIHZhciBvbkZvY3VzQ2IgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgZGlzcGF0Y2goe1xuICAgICAgdHlwZTogXCJmb2N1c1wiXG4gICAgfSk7XG4gIH0sIFtdKTtcbiAgdmFyIG9uQmx1ckNiID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIGRpc3BhdGNoKHtcbiAgICAgIHR5cGU6IFwiYmx1clwiXG4gICAgfSk7XG4gIH0sIFtdKTsgLy8gQ2IgdG8gb3BlbiB0aGUgZmlsZSBkaWFsb2cgd2hlbiBjbGljayBvY2N1cnMgb24gdGhlIGRyb3B6b25lXG5cbiAgdmFyIG9uQ2xpY2tDYiA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAobm9DbGljaykge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gSW4gSUUxMS9FZGdlIHRoZSBmaWxlLWJyb3dzZXIgZGlhbG9nIGlzIGJsb2NraW5nLCB0aGVyZWZvcmUsIHVzZSBzZXRUaW1lb3V0KClcbiAgICAvLyB0byBlbnN1cmUgUmVhY3QgY2FuIGhhbmRsZSBzdGF0ZSBjaGFuZ2VzXG4gICAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vcmVhY3QtZHJvcHpvbmUvcmVhY3QtZHJvcHpvbmUvaXNzdWVzLzQ1MFxuXG5cbiAgICBpZiAoaXNJZU9yRWRnZSgpKSB7XG4gICAgICBzZXRUaW1lb3V0KG9wZW5GaWxlRGlhbG9nLCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3BlbkZpbGVEaWFsb2coKTtcbiAgICB9XG4gIH0sIFtub0NsaWNrLCBvcGVuRmlsZURpYWxvZ10pO1xuXG4gIHZhciBjb21wb3NlSGFuZGxlciA9IGZ1bmN0aW9uIGNvbXBvc2VIYW5kbGVyKGZuKSB7XG4gICAgcmV0dXJuIGRpc2FibGVkID8gbnVsbCA6IGZuO1xuICB9O1xuXG4gIHZhciBjb21wb3NlS2V5Ym9hcmRIYW5kbGVyID0gZnVuY3Rpb24gY29tcG9zZUtleWJvYXJkSGFuZGxlcihmbikge1xuICAgIHJldHVybiBub0tleWJvYXJkID8gbnVsbCA6IGNvbXBvc2VIYW5kbGVyKGZuKTtcbiAgfTtcblxuICB2YXIgY29tcG9zZURyYWdIYW5kbGVyID0gZnVuY3Rpb24gY29tcG9zZURyYWdIYW5kbGVyKGZuKSB7XG4gICAgcmV0dXJuIG5vRHJhZyA/IG51bGwgOiBjb21wb3NlSGFuZGxlcihmbik7XG4gIH07XG5cbiAgdmFyIHN0b3BQcm9wYWdhdGlvbiA9IGZ1bmN0aW9uIHN0b3BQcm9wYWdhdGlvbihldmVudCkge1xuICAgIGlmIChub0RyYWdFdmVudHNCdWJibGluZykge1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBnZXRSb290UHJvcHMgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9yZWYyID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgICAgICBfcmVmMiRyZWZLZXkgPSBfcmVmMi5yZWZLZXksXG4gICAgICAgICAgcmVmS2V5ID0gX3JlZjIkcmVmS2V5ID09PSB2b2lkIDAgPyBcInJlZlwiIDogX3JlZjIkcmVmS2V5LFxuICAgICAgICAgIHJvbGUgPSBfcmVmMi5yb2xlLFxuICAgICAgICAgIG9uS2V5RG93biA9IF9yZWYyLm9uS2V5RG93bixcbiAgICAgICAgICBvbkZvY3VzID0gX3JlZjIub25Gb2N1cyxcbiAgICAgICAgICBvbkJsdXIgPSBfcmVmMi5vbkJsdXIsXG4gICAgICAgICAgb25DbGljayA9IF9yZWYyLm9uQ2xpY2ssXG4gICAgICAgICAgb25EcmFnRW50ZXIgPSBfcmVmMi5vbkRyYWdFbnRlcixcbiAgICAgICAgICBvbkRyYWdPdmVyID0gX3JlZjIub25EcmFnT3ZlcixcbiAgICAgICAgICBvbkRyYWdMZWF2ZSA9IF9yZWYyLm9uRHJhZ0xlYXZlLFxuICAgICAgICAgIG9uRHJvcCA9IF9yZWYyLm9uRHJvcCxcbiAgICAgICAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYyLCBfZXhjbHVkZWQzKTtcblxuICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZChfZGVmaW5lUHJvcGVydHkoe1xuICAgICAgICBvbktleURvd246IGNvbXBvc2VLZXlib2FyZEhhbmRsZXIoY29tcG9zZUV2ZW50SGFuZGxlcnMob25LZXlEb3duLCBvbktleURvd25DYikpLFxuICAgICAgICBvbkZvY3VzOiBjb21wb3NlS2V5Ym9hcmRIYW5kbGVyKGNvbXBvc2VFdmVudEhhbmRsZXJzKG9uRm9jdXMsIG9uRm9jdXNDYikpLFxuICAgICAgICBvbkJsdXI6IGNvbXBvc2VLZXlib2FyZEhhbmRsZXIoY29tcG9zZUV2ZW50SGFuZGxlcnMob25CbHVyLCBvbkJsdXJDYikpLFxuICAgICAgICBvbkNsaWNrOiBjb21wb3NlSGFuZGxlcihjb21wb3NlRXZlbnRIYW5kbGVycyhvbkNsaWNrLCBvbkNsaWNrQ2IpKSxcbiAgICAgICAgb25EcmFnRW50ZXI6IGNvbXBvc2VEcmFnSGFuZGxlcihjb21wb3NlRXZlbnRIYW5kbGVycyhvbkRyYWdFbnRlciwgb25EcmFnRW50ZXJDYikpLFxuICAgICAgICBvbkRyYWdPdmVyOiBjb21wb3NlRHJhZ0hhbmRsZXIoY29tcG9zZUV2ZW50SGFuZGxlcnMob25EcmFnT3Zlciwgb25EcmFnT3ZlckNiKSksXG4gICAgICAgIG9uRHJhZ0xlYXZlOiBjb21wb3NlRHJhZ0hhbmRsZXIoY29tcG9zZUV2ZW50SGFuZGxlcnMob25EcmFnTGVhdmUsIG9uRHJhZ0xlYXZlQ2IpKSxcbiAgICAgICAgb25Ecm9wOiBjb21wb3NlRHJhZ0hhbmRsZXIoY29tcG9zZUV2ZW50SGFuZGxlcnMob25Ecm9wLCBvbkRyb3BDYikpLFxuICAgICAgICByb2xlOiB0eXBlb2Ygcm9sZSA9PT0gXCJzdHJpbmdcIiAmJiByb2xlICE9PSBcIlwiID8gcm9sZSA6IFwicHJlc2VudGF0aW9uXCJcbiAgICAgIH0sIHJlZktleSwgcm9vdFJlZiksICFkaXNhYmxlZCAmJiAhbm9LZXlib2FyZCA/IHtcbiAgICAgICAgdGFiSW5kZXg6IDBcbiAgICAgIH0gOiB7fSksIHJlc3QpO1xuICAgIH07XG4gIH0sIFtyb290UmVmLCBvbktleURvd25DYiwgb25Gb2N1c0NiLCBvbkJsdXJDYiwgb25DbGlja0NiLCBvbkRyYWdFbnRlckNiLCBvbkRyYWdPdmVyQ2IsIG9uRHJhZ0xlYXZlQ2IsIG9uRHJvcENiLCBub0tleWJvYXJkLCBub0RyYWcsIGRpc2FibGVkXSk7XG4gIHZhciBvbklucHV0RWxlbWVudENsaWNrID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH0sIFtdKTtcbiAgdmFyIGdldElucHV0UHJvcHMgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9yZWYzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgICAgICBfcmVmMyRyZWZLZXkgPSBfcmVmMy5yZWZLZXksXG4gICAgICAgICAgcmVmS2V5ID0gX3JlZjMkcmVmS2V5ID09PSB2b2lkIDAgPyBcInJlZlwiIDogX3JlZjMkcmVmS2V5LFxuICAgICAgICAgIG9uQ2hhbmdlID0gX3JlZjMub25DaGFuZ2UsXG4gICAgICAgICAgb25DbGljayA9IF9yZWYzLm9uQ2xpY2ssXG4gICAgICAgICAgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmMywgX2V4Y2x1ZGVkNCk7XG5cbiAgICAgIHZhciBpbnB1dFByb3BzID0gX2RlZmluZVByb3BlcnR5KHtcbiAgICAgICAgYWNjZXB0OiBhY2NlcHRBdHRyLFxuICAgICAgICBtdWx0aXBsZTogbXVsdGlwbGUsXG4gICAgICAgIHR5cGU6IFwiZmlsZVwiLFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIGJvcmRlcjogMCxcbiAgICAgICAgICBjbGlwOiBcInJlY3QoMCwgMCwgMCwgMClcIixcbiAgICAgICAgICBjbGlwUGF0aDogXCJpbnNldCg1MCUpXCIsXG4gICAgICAgICAgaGVpZ2h0OiBcIjFweFwiLFxuICAgICAgICAgIG1hcmdpbjogXCIwIC0xcHggLTFweCAwXCIsXG4gICAgICAgICAgb3ZlcmZsb3c6IFwiaGlkZGVuXCIsXG4gICAgICAgICAgcGFkZGluZzogMCxcbiAgICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICAgIHdpZHRoOiBcIjFweFwiLFxuICAgICAgICAgIHdoaXRlU3BhY2U6IFwibm93cmFwXCJcbiAgICAgICAgfSxcbiAgICAgICAgb25DaGFuZ2U6IGNvbXBvc2VIYW5kbGVyKGNvbXBvc2VFdmVudEhhbmRsZXJzKG9uQ2hhbmdlLCBvbkRyb3BDYikpLFxuICAgICAgICBvbkNsaWNrOiBjb21wb3NlSGFuZGxlcihjb21wb3NlRXZlbnRIYW5kbGVycyhvbkNsaWNrLCBvbklucHV0RWxlbWVudENsaWNrKSksXG4gICAgICAgIHRhYkluZGV4OiAtMVxuICAgICAgfSwgcmVmS2V5LCBpbnB1dFJlZik7XG5cbiAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGlucHV0UHJvcHMpLCByZXN0KTtcbiAgICB9O1xuICB9LCBbaW5wdXRSZWYsIGFjY2VwdCwgbXVsdGlwbGUsIG9uRHJvcENiLCBkaXNhYmxlZF0pO1xuICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBzdGF0ZSksIHt9LCB7XG4gICAgaXNGb2N1c2VkOiBpc0ZvY3VzZWQgJiYgIWRpc2FibGVkLFxuICAgIGdldFJvb3RQcm9wczogZ2V0Um9vdFByb3BzLFxuICAgIGdldElucHV0UHJvcHM6IGdldElucHV0UHJvcHMsXG4gICAgcm9vdFJlZjogcm9vdFJlZixcbiAgICBpbnB1dFJlZjogaW5wdXRSZWYsXG4gICAgb3BlbjogY29tcG9zZUhhbmRsZXIob3BlbkZpbGVEaWFsb2cpXG4gIH0pO1xufVxuLyoqXG4gKiBAcGFyYW0ge0Ryb3B6b25lU3RhdGV9IHN0YXRlXG4gKiBAcGFyYW0ge3t0eXBlOiBzdHJpbmd9ICYgRHJvcHpvbmVTdGF0ZX0gYWN0aW9uXG4gKiBAcmV0dXJucyB7RHJvcHpvbmVTdGF0ZX1cbiAqL1xuXG5mdW5jdGlvbiByZWR1Y2VyKHN0YXRlLCBhY3Rpb24pIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIGNhc2UgXCJmb2N1c1wiOlxuICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgc3RhdGUpLCB7fSwge1xuICAgICAgICBpc0ZvY3VzZWQ6IHRydWVcbiAgICAgIH0pO1xuXG4gICAgY2FzZSBcImJsdXJcIjpcbiAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHN0YXRlKSwge30sIHtcbiAgICAgICAgaXNGb2N1c2VkOiBmYWxzZVxuICAgICAgfSk7XG5cbiAgICBjYXNlIFwib3BlbkRpYWxvZ1wiOlxuICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgaW5pdGlhbFN0YXRlKSwge30sIHtcbiAgICAgICAgaXNGaWxlRGlhbG9nQWN0aXZlOiB0cnVlXG4gICAgICB9KTtcblxuICAgIGNhc2UgXCJjbG9zZURpYWxvZ1wiOlxuICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgc3RhdGUpLCB7fSwge1xuICAgICAgICBpc0ZpbGVEaWFsb2dBY3RpdmU6IGZhbHNlXG4gICAgICB9KTtcblxuICAgIGNhc2UgXCJzZXREcmFnZ2VkRmlsZXNcIjpcbiAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHN0YXRlKSwge30sIHtcbiAgICAgICAgaXNEcmFnQWN0aXZlOiBhY3Rpb24uaXNEcmFnQWN0aXZlLFxuICAgICAgICBpc0RyYWdBY2NlcHQ6IGFjdGlvbi5pc0RyYWdBY2NlcHQsXG4gICAgICAgIGlzRHJhZ1JlamVjdDogYWN0aW9uLmlzRHJhZ1JlamVjdFxuICAgICAgfSk7XG5cbiAgICBjYXNlIFwic2V0RmlsZXNcIjpcbiAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHN0YXRlKSwge30sIHtcbiAgICAgICAgYWNjZXB0ZWRGaWxlczogYWN0aW9uLmFjY2VwdGVkRmlsZXMsXG4gICAgICAgIGZpbGVSZWplY3Rpb25zOiBhY3Rpb24uZmlsZVJlamVjdGlvbnMsXG4gICAgICAgIGlzRHJhZ1JlamVjdDogYWN0aW9uLmlzRHJhZ1JlamVjdFxuICAgICAgfSk7XG5cbiAgICBjYXNlIFwicmVzZXRcIjpcbiAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKHt9LCBpbml0aWFsU3RhdGUpO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBub29wKCkge31cblxuZXhwb3J0IHsgRXJyb3JDb2RlIH0gZnJvbSBcIi4vdXRpbHNcIjsiXSwibmFtZXMiOlsiX2V4Y2x1ZGVkIiwiX2V4Y2x1ZGVkMiIsIl9leGNsdWRlZDMiLCJfZXhjbHVkZWQ0IiwiX3RvQ29uc3VtYWJsZUFycmF5IiwiYXJyIiwiX2FycmF5V2l0aG91dEhvbGVzIiwiX2l0ZXJhYmxlVG9BcnJheSIsIl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSIsIl9ub25JdGVyYWJsZVNwcmVhZCIsIlR5cGVFcnJvciIsIml0ZXIiLCJTeW1ib2wiLCJpdGVyYXRvciIsIkFycmF5IiwiZnJvbSIsImlzQXJyYXkiLCJfYXJyYXlMaWtlVG9BcnJheSIsIl9zbGljZWRUb0FycmF5IiwiaSIsIl9hcnJheVdpdGhIb2xlcyIsIl9pdGVyYWJsZVRvQXJyYXlMaW1pdCIsIl9ub25JdGVyYWJsZVJlc3QiLCJvIiwibWluTGVuIiwibiIsIk9iamVjdCIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiY2FsbCIsInNsaWNlIiwiY29uc3RydWN0b3IiLCJuYW1lIiwidGVzdCIsImxlbiIsImxlbmd0aCIsImFycjIiLCJfaSIsIl9hcnIiLCJfbiIsIl9kIiwiX3MiLCJfZSIsIm5leHQiLCJkb25lIiwicHVzaCIsInZhbHVlIiwiZXJyIiwib3duS2V5cyIsIm9iamVjdCIsImVudW1lcmFibGVPbmx5Iiwia2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsInN5bWJvbHMiLCJmaWx0ZXIiLCJzeW0iLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwiYXBwbHkiLCJfb2JqZWN0U3ByZWFkIiwidGFyZ2V0IiwiYXJndW1lbnRzIiwic291cmNlIiwiZm9yRWFjaCIsImtleSIsIl9kZWZpbmVQcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiZGVmaW5lUHJvcGVydHkiLCJvYmoiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllcyIsImV4Y2x1ZGVkIiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UiLCJzb3VyY2VTeW1ib2xLZXlzIiwiaW5kZXhPZiIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwic291cmNlS2V5cyIsIlJlYWN0IiwiZm9yd2FyZFJlZiIsIkZyYWdtZW50IiwidXNlQ2FsbGJhY2siLCJ1c2VFZmZlY3QiLCJ1c2VJbXBlcmF0aXZlSGFuZGxlIiwidXNlTWVtbyIsInVzZVJlZHVjZXIiLCJ1c2VSZWYiLCJQcm9wVHlwZXMiLCJmcm9tRXZlbnQiLCJhY2NlcHRQcm9wQXNBY2NlcHRBdHRyIiwiYWxsRmlsZXNBY2NlcHRlZCIsImNvbXBvc2VFdmVudEhhbmRsZXJzIiwiZmlsZUFjY2VwdGVkIiwiZmlsZU1hdGNoU2l6ZSIsImNhblVzZUZpbGVTeXN0ZW1BY2Nlc3NBUEkiLCJpc0Fib3J0IiwiaXNFdnRXaXRoRmlsZXMiLCJpc0llT3JFZGdlIiwiaXNQcm9wYWdhdGlvblN0b3BwZWQiLCJpc1NlY3VyaXR5RXJyb3IiLCJvbkRvY3VtZW50RHJhZ092ZXIiLCJwaWNrZXJPcHRpb25zRnJvbUFjY2VwdCIsIlRPT19NQU5ZX0ZJTEVTX1JFSkVDVElPTiIsIkRyb3B6b25lIiwiX3JlZiIsInJlZiIsImNoaWxkcmVuIiwicGFyYW1zIiwiX3VzZURyb3B6b25lIiwidXNlRHJvcHpvbmUiLCJvcGVuIiwicHJvcHMiLCJjcmVhdGVFbGVtZW50IiwiZGlzcGxheU5hbWUiLCJkZWZhdWx0UHJvcHMiLCJkaXNhYmxlZCIsImdldEZpbGVzRnJvbUV2ZW50IiwibWF4U2l6ZSIsIkluZmluaXR5IiwibWluU2l6ZSIsIm11bHRpcGxlIiwibWF4RmlsZXMiLCJwcmV2ZW50RHJvcE9uRG9jdW1lbnQiLCJub0NsaWNrIiwibm9LZXlib2FyZCIsIm5vRHJhZyIsIm5vRHJhZ0V2ZW50c0J1YmJsaW5nIiwidmFsaWRhdG9yIiwidXNlRnNBY2Nlc3NBcGkiLCJhdXRvRm9jdXMiLCJwcm9wVHlwZXMiLCJmdW5jIiwiYWNjZXB0Iiwib2JqZWN0T2YiLCJhcnJheU9mIiwic3RyaW5nIiwiYm9vbCIsIm51bWJlciIsIm9uRmlsZURpYWxvZ0NhbmNlbCIsIm9uRmlsZURpYWxvZ09wZW4iLCJvbkRyYWdFbnRlciIsIm9uRHJhZ0xlYXZlIiwib25EcmFnT3ZlciIsIm9uRHJvcCIsIm9uRHJvcEFjY2VwdGVkIiwib25Ecm9wUmVqZWN0ZWQiLCJvbkVycm9yIiwiaW5pdGlhbFN0YXRlIiwiaXNGb2N1c2VkIiwiaXNGaWxlRGlhbG9nQWN0aXZlIiwiaXNEcmFnQWN0aXZlIiwiaXNEcmFnQWNjZXB0IiwiaXNEcmFnUmVqZWN0IiwiYWNjZXB0ZWRGaWxlcyIsImZpbGVSZWplY3Rpb25zIiwidW5kZWZpbmVkIiwiX2RlZmF1bHRQcm9wcyRwcm9wcyIsImFjY2VwdEF0dHIiLCJwaWNrZXJUeXBlcyIsIm9uRmlsZURpYWxvZ09wZW5DYiIsIm5vb3AiLCJvbkZpbGVEaWFsb2dDYW5jZWxDYiIsInJvb3RSZWYiLCJpbnB1dFJlZiIsIl91c2VSZWR1Y2VyIiwicmVkdWNlciIsIl91c2VSZWR1Y2VyMiIsInN0YXRlIiwiZGlzcGF0Y2giLCJmc0FjY2Vzc0FwaVdvcmtzUmVmIiwid2luZG93IiwiaXNTZWN1cmVDb250ZXh0Iiwib25XaW5kb3dGb2N1cyIsImN1cnJlbnQiLCJzZXRUaW1lb3V0IiwiZmlsZXMiLCJ0eXBlIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJkcmFnVGFyZ2V0c1JlZiIsIm9uRG9jdW1lbnREcm9wIiwiZXZlbnQiLCJjb250YWlucyIsInByZXZlbnREZWZhdWx0IiwiZG9jdW1lbnQiLCJmb2N1cyIsIm9uRXJyQ2IiLCJlIiwiY29uc29sZSIsImVycm9yIiwib25EcmFnRW50ZXJDYiIsInBlcnNpc3QiLCJzdG9wUHJvcGFnYXRpb24iLCJjb25jYXQiLCJQcm9taXNlIiwicmVzb2x2ZSIsInRoZW4iLCJmaWxlQ291bnQiLCJjYXRjaCIsIm9uRHJhZ092ZXJDYiIsImhhc0ZpbGVzIiwiZGF0YVRyYW5zZmVyIiwiZHJvcEVmZmVjdCIsIl91bnVzZWQiLCJvbkRyYWdMZWF2ZUNiIiwidGFyZ2V0cyIsInRhcmdldElkeCIsInNwbGljZSIsInNldEZpbGVzIiwiZmlsZSIsIl9maWxlQWNjZXB0ZWQiLCJfZmlsZUFjY2VwdGVkMiIsImFjY2VwdGVkIiwiYWNjZXB0RXJyb3IiLCJfZmlsZU1hdGNoU2l6ZSIsIl9maWxlTWF0Y2hTaXplMiIsInNpemVNYXRjaCIsInNpemVFcnJvciIsImN1c3RvbUVycm9ycyIsImVycm9ycyIsIm9uRHJvcENiIiwib3BlbkZpbGVEaWFsb2ciLCJvcHRzIiwidHlwZXMiLCJzaG93T3BlbkZpbGVQaWNrZXIiLCJoYW5kbGVzIiwiY2xpY2siLCJFcnJvciIsIm9uS2V5RG93bkNiIiwiaXNFcXVhbE5vZGUiLCJrZXlDb2RlIiwib25Gb2N1c0NiIiwib25CbHVyQ2IiLCJvbkNsaWNrQ2IiLCJjb21wb3NlSGFuZGxlciIsImZuIiwiY29tcG9zZUtleWJvYXJkSGFuZGxlciIsImNvbXBvc2VEcmFnSGFuZGxlciIsImdldFJvb3RQcm9wcyIsIl9yZWYyIiwiX3JlZjIkcmVmS2V5IiwicmVmS2V5Iiwicm9sZSIsIm9uS2V5RG93biIsIm9uRm9jdXMiLCJvbkJsdXIiLCJvbkNsaWNrIiwicmVzdCIsInRhYkluZGV4Iiwib25JbnB1dEVsZW1lbnRDbGljayIsImdldElucHV0UHJvcHMiLCJfcmVmMyIsIl9yZWYzJHJlZktleSIsIm9uQ2hhbmdlIiwiaW5wdXRQcm9wcyIsInN0eWxlIiwiYm9yZGVyIiwiY2xpcCIsImNsaXBQYXRoIiwiaGVpZ2h0IiwibWFyZ2luIiwib3ZlcmZsb3ciLCJwYWRkaW5nIiwicG9zaXRpb24iLCJ3aWR0aCIsIndoaXRlU3BhY2UiLCJhY3Rpb24iLCJFcnJvckNvZGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-dropzone/dist/es/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-dropzone/dist/es/utils/index.js":
/*!************************************************************!*\
  !*** ./node_modules/react-dropzone/dist/es/utils/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ErrorCode: () => (/* binding */ ErrorCode),\n/* harmony export */   FILE_INVALID_TYPE: () => (/* binding */ FILE_INVALID_TYPE),\n/* harmony export */   FILE_TOO_LARGE: () => (/* binding */ FILE_TOO_LARGE),\n/* harmony export */   FILE_TOO_SMALL: () => (/* binding */ FILE_TOO_SMALL),\n/* harmony export */   TOO_MANY_FILES: () => (/* binding */ TOO_MANY_FILES),\n/* harmony export */   TOO_MANY_FILES_REJECTION: () => (/* binding */ TOO_MANY_FILES_REJECTION),\n/* harmony export */   acceptPropAsAcceptAttr: () => (/* binding */ acceptPropAsAcceptAttr),\n/* harmony export */   allFilesAccepted: () => (/* binding */ allFilesAccepted),\n/* harmony export */   canUseFileSystemAccessAPI: () => (/* binding */ canUseFileSystemAccessAPI),\n/* harmony export */   composeEventHandlers: () => (/* binding */ composeEventHandlers),\n/* harmony export */   fileAccepted: () => (/* binding */ fileAccepted),\n/* harmony export */   fileMatchSize: () => (/* binding */ fileMatchSize),\n/* harmony export */   getInvalidTypeRejectionErr: () => (/* binding */ getInvalidTypeRejectionErr),\n/* harmony export */   getTooLargeRejectionErr: () => (/* binding */ getTooLargeRejectionErr),\n/* harmony export */   getTooSmallRejectionErr: () => (/* binding */ getTooSmallRejectionErr),\n/* harmony export */   isAbort: () => (/* binding */ isAbort),\n/* harmony export */   isEvtWithFiles: () => (/* binding */ isEvtWithFiles),\n/* harmony export */   isExt: () => (/* binding */ isExt),\n/* harmony export */   isIeOrEdge: () => (/* binding */ isIeOrEdge),\n/* harmony export */   isKindFile: () => (/* binding */ isKindFile),\n/* harmony export */   isMIMEType: () => (/* binding */ isMIMEType),\n/* harmony export */   isPropagationStopped: () => (/* binding */ isPropagationStopped),\n/* harmony export */   isSecurityError: () => (/* binding */ isSecurityError),\n/* harmony export */   onDocumentDragOver: () => (/* binding */ onDocumentDragOver),\n/* harmony export */   pickerOptionsFromAccept: () => (/* binding */ pickerOptionsFromAccept)\n/* harmony export */ });\n/* harmony import */ var attr_accept__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! attr-accept */ \"(ssr)/./node_modules/attr-accept/dist/es/index.js\");\nfunction _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        enumerableOnly && (symbols = symbols.filter(function(sym) {\n            return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n        })), keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = null != arguments[i] ? arguments[i] : {};\n        i % 2 ? ownKeys(Object(source), !0).forEach(function(key) {\n            _defineProperty(target, key, source[key]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n    }\n    return target;\n}\nfunction _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _typeof(obj) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj) {\n        return typeof obj;\n    } : function(obj) {\n        return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    }, _typeof(obj);\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++){\n        arr2[i] = arr[i];\n    }\n    return arr2;\n}\nfunction _iterableToArrayLimit(arr, i) {\n    var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n    if (_i == null) return;\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _s, _e;\n    try {\n        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){\n            _arr.push(_s.value);\n            if (i && _arr.length === i) break;\n        }\n    } catch (err) {\n        _d = true;\n        _e = err;\n    } finally{\n        try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n        } finally{\n            if (_d) throw _e;\n        }\n    }\n    return _arr;\n}\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\n\nvar accepts = typeof attr_accept__WEBPACK_IMPORTED_MODULE_0__[\"default\"] === \"function\" ? attr_accept__WEBPACK_IMPORTED_MODULE_0__[\"default\"] : attr_accept__WEBPACK_IMPORTED_MODULE_0__[\"default\"][\"default\"]; // Error codes\nvar FILE_INVALID_TYPE = \"file-invalid-type\";\nvar FILE_TOO_LARGE = \"file-too-large\";\nvar FILE_TOO_SMALL = \"file-too-small\";\nvar TOO_MANY_FILES = \"too-many-files\";\nvar ErrorCode = {\n    FileInvalidType: FILE_INVALID_TYPE,\n    FileTooLarge: FILE_TOO_LARGE,\n    FileTooSmall: FILE_TOO_SMALL,\n    TooManyFiles: TOO_MANY_FILES\n};\n/**\n *\n * @param {string} accept\n */ var getInvalidTypeRejectionErr = function getInvalidTypeRejectionErr() {\n    var accept = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    var acceptArr = accept.split(\",\");\n    var msg = acceptArr.length > 1 ? \"one of \".concat(acceptArr.join(\", \")) : acceptArr[0];\n    return {\n        code: FILE_INVALID_TYPE,\n        message: \"File type must be \".concat(msg)\n    };\n};\nvar getTooLargeRejectionErr = function getTooLargeRejectionErr(maxSize) {\n    return {\n        code: FILE_TOO_LARGE,\n        message: \"File is larger than \".concat(maxSize, \" \").concat(maxSize === 1 ? \"byte\" : \"bytes\")\n    };\n};\nvar getTooSmallRejectionErr = function getTooSmallRejectionErr(minSize) {\n    return {\n        code: FILE_TOO_SMALL,\n        message: \"File is smaller than \".concat(minSize, \" \").concat(minSize === 1 ? \"byte\" : \"bytes\")\n    };\n};\nvar TOO_MANY_FILES_REJECTION = {\n    code: TOO_MANY_FILES,\n    message: \"Too many files\"\n};\n/**\n * Check if file is accepted.\n *\n * Firefox versions prior to 53 return a bogus MIME type for every file drag,\n * so dragovers with that MIME type will always be accepted.\n *\n * @param {File} file\n * @param {string} accept\n * @returns\n */ function fileAccepted(file, accept) {\n    var isAcceptable = file.type === \"application/x-moz-file\" || accepts(file, accept);\n    return [\n        isAcceptable,\n        isAcceptable ? null : getInvalidTypeRejectionErr(accept)\n    ];\n}\nfunction fileMatchSize(file, minSize, maxSize) {\n    if (isDefined(file.size)) {\n        if (isDefined(minSize) && isDefined(maxSize)) {\n            if (file.size > maxSize) return [\n                false,\n                getTooLargeRejectionErr(maxSize)\n            ];\n            if (file.size < minSize) return [\n                false,\n                getTooSmallRejectionErr(minSize)\n            ];\n        } else if (isDefined(minSize) && file.size < minSize) return [\n            false,\n            getTooSmallRejectionErr(minSize)\n        ];\n        else if (isDefined(maxSize) && file.size > maxSize) return [\n            false,\n            getTooLargeRejectionErr(maxSize)\n        ];\n    }\n    return [\n        true,\n        null\n    ];\n}\nfunction isDefined(value) {\n    return value !== undefined && value !== null;\n}\n/**\n *\n * @param {object} options\n * @param {File[]} options.files\n * @param {string} [options.accept]\n * @param {number} [options.minSize]\n * @param {number} [options.maxSize]\n * @param {boolean} [options.multiple]\n * @param {number} [options.maxFiles]\n * @param {(f: File) => FileError|FileError[]|null} [options.validator]\n * @returns\n */ function allFilesAccepted(_ref) {\n    var files = _ref.files, accept = _ref.accept, minSize = _ref.minSize, maxSize = _ref.maxSize, multiple = _ref.multiple, maxFiles = _ref.maxFiles, validator = _ref.validator;\n    if (!multiple && files.length > 1 || multiple && maxFiles >= 1 && files.length > maxFiles) {\n        return false;\n    }\n    return files.every(function(file) {\n        var _fileAccepted = fileAccepted(file, accept), _fileAccepted2 = _slicedToArray(_fileAccepted, 1), accepted = _fileAccepted2[0];\n        var _fileMatchSize = fileMatchSize(file, minSize, maxSize), _fileMatchSize2 = _slicedToArray(_fileMatchSize, 1), sizeMatch = _fileMatchSize2[0];\n        var customErrors = validator ? validator(file) : null;\n        return accepted && sizeMatch && !customErrors;\n    });\n} // React's synthetic events has event.isPropagationStopped,\n// but to remain compatibility with other libs (Preact) fall back\n// to check event.cancelBubble\nfunction isPropagationStopped(event) {\n    if (typeof event.isPropagationStopped === \"function\") {\n        return event.isPropagationStopped();\n    } else if (typeof event.cancelBubble !== \"undefined\") {\n        return event.cancelBubble;\n    }\n    return false;\n}\nfunction isEvtWithFiles(event) {\n    if (!event.dataTransfer) {\n        return !!event.target && !!event.target.files;\n    } // https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer/types\n    // https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API/Recommended_drag_types#file\n    return Array.prototype.some.call(event.dataTransfer.types, function(type) {\n        return type === \"Files\" || type === \"application/x-moz-file\";\n    });\n}\nfunction isKindFile(item) {\n    return _typeof(item) === \"object\" && item !== null && item.kind === \"file\";\n} // allow the entire document to be a drag target\nfunction onDocumentDragOver(event) {\n    event.preventDefault();\n}\nfunction isIe(userAgent) {\n    return userAgent.indexOf(\"MSIE\") !== -1 || userAgent.indexOf(\"Trident/\") !== -1;\n}\nfunction isEdge(userAgent) {\n    return userAgent.indexOf(\"Edge/\") !== -1;\n}\nfunction isIeOrEdge() {\n    var userAgent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window.navigator.userAgent;\n    return isIe(userAgent) || isEdge(userAgent);\n}\n/**\n * This is intended to be used to compose event handlers\n * They are executed in order until one of them calls `event.isPropagationStopped()`.\n * Note that the check is done on the first invoke too,\n * meaning that if propagation was stopped before invoking the fns,\n * no handlers will be executed.\n *\n * @param {Function} fns the event hanlder functions\n * @return {Function} the event handler to add to an element\n */ function composeEventHandlers() {\n    for(var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++){\n        fns[_key] = arguments[_key];\n    }\n    return function(event) {\n        for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n            args[_key2 - 1] = arguments[_key2];\n        }\n        return fns.some(function(fn) {\n            if (!isPropagationStopped(event) && fn) {\n                fn.apply(void 0, [\n                    event\n                ].concat(args));\n            }\n            return isPropagationStopped(event);\n        });\n    };\n}\n/**\n * canUseFileSystemAccessAPI checks if the [File System Access API](https://developer.mozilla.org/en-US/docs/Web/API/File_System_Access_API)\n * is supported by the browser.\n * @returns {boolean}\n */ function canUseFileSystemAccessAPI() {\n    return \"showOpenFilePicker\" in window;\n}\n/**\n * Convert the `{accept}` dropzone prop to the\n * `{types}` option for https://developer.mozilla.org/en-US/docs/Web/API/window/showOpenFilePicker\n *\n * @param {AcceptProp} accept\n * @returns {{accept: string[]}[]}\n */ function pickerOptionsFromAccept(accept) {\n    if (isDefined(accept)) {\n        var acceptForPicker = Object.entries(accept).filter(function(_ref2) {\n            var _ref3 = _slicedToArray(_ref2, 2), mimeType = _ref3[0], ext = _ref3[1];\n            var ok = true;\n            if (!isMIMEType(mimeType)) {\n                console.warn('Skipped \"'.concat(mimeType, '\" because it is not a valid MIME type. Check https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types for a list of valid MIME types.'));\n                ok = false;\n            }\n            if (!Array.isArray(ext) || !ext.every(isExt)) {\n                console.warn('Skipped \"'.concat(mimeType, '\" because an invalid file extension was provided.'));\n                ok = false;\n            }\n            return ok;\n        }).reduce(function(agg, _ref4) {\n            var _ref5 = _slicedToArray(_ref4, 2), mimeType = _ref5[0], ext = _ref5[1];\n            return _objectSpread(_objectSpread({}, agg), {}, _defineProperty({}, mimeType, ext));\n        }, {});\n        return [\n            {\n                // description is required due to https://crbug.com/1264708\n                description: \"Files\",\n                accept: acceptForPicker\n            }\n        ];\n    }\n    return accept;\n}\n/**\n * Convert the `{accept}` dropzone prop to an array of MIME types/extensions.\n * @param {AcceptProp} accept\n * @returns {string}\n */ function acceptPropAsAcceptAttr(accept) {\n    if (isDefined(accept)) {\n        return Object.entries(accept).reduce(function(a, _ref6) {\n            var _ref7 = _slicedToArray(_ref6, 2), mimeType = _ref7[0], ext = _ref7[1];\n            return [].concat(_toConsumableArray(a), [\n                mimeType\n            ], _toConsumableArray(ext));\n        }, []) // Silently discard invalid entries as pickerOptionsFromAccept warns about these\n        .filter(function(v) {\n            return isMIMEType(v) || isExt(v);\n        }).join(\",\");\n    }\n    return undefined;\n}\n/**\n * Check if v is an exception caused by aborting a request (e.g window.showOpenFilePicker()).\n *\n * See https://developer.mozilla.org/en-US/docs/Web/API/DOMException.\n * @param {any} v\n * @returns {boolean} True if v is an abort exception.\n */ function isAbort(v) {\n    return v instanceof DOMException && (v.name === \"AbortError\" || v.code === v.ABORT_ERR);\n}\n/**\n * Check if v is a security error.\n *\n * See https://developer.mozilla.org/en-US/docs/Web/API/DOMException.\n * @param {any} v\n * @returns {boolean} True if v is a security error.\n */ function isSecurityError(v) {\n    return v instanceof DOMException && (v.name === \"SecurityError\" || v.code === v.SECURITY_ERR);\n}\n/**\n * Check if v is a MIME type string.\n *\n * See accepted format: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/file#unique_file_type_specifiers.\n *\n * @param {string} v\n */ function isMIMEType(v) {\n    return v === \"audio/*\" || v === \"video/*\" || v === \"image/*\" || v === \"text/*\" || v === \"application/*\" || /\\w+\\/[-+.\\w]+/g.test(v);\n}\n/**\n * Check if v is a file extension.\n * @param {string} v\n */ function isExt(v) {\n    return /^.*\\.[\\w]+$/.test(v);\n} /**\n * @typedef {Object.<string, string[]>} AcceptProp\n */  /**\n * @typedef {object} FileError\n * @property {string} message\n * @property {ErrorCode|string} code\n */  /**\n * @typedef {\"file-invalid-type\"|\"file-too-large\"|\"file-too-small\"|\"too-many-files\"} ErrorCode\n */ \n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtZHJvcHpvbmUvZGlzdC9lcy91dGlscy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLFNBQVNBLG1CQUFtQkMsR0FBRztJQUFJLE9BQU9DLG1CQUFtQkQsUUFBUUUsaUJBQWlCRixRQUFRRyw0QkFBNEJILFFBQVFJO0FBQXNCO0FBRXhKLFNBQVNBO0lBQXVCLE1BQU0sSUFBSUMsVUFBVTtBQUF5STtBQUU3TCxTQUFTSCxpQkFBaUJJLElBQUk7SUFBSSxJQUFJLE9BQU9DLFdBQVcsZUFBZUQsSUFBSSxDQUFDQyxPQUFPQyxRQUFRLENBQUMsSUFBSSxRQUFRRixJQUFJLENBQUMsYUFBYSxJQUFJLE1BQU0sT0FBT0csTUFBTUMsSUFBSSxDQUFDSjtBQUFPO0FBRTdKLFNBQVNMLG1CQUFtQkQsR0FBRztJQUFJLElBQUlTLE1BQU1FLE9BQU8sQ0FBQ1gsTUFBTSxPQUFPWSxrQkFBa0JaO0FBQU07QUFFMUYsU0FBU2EsUUFBUUMsTUFBTSxFQUFFQyxjQUFjO0lBQUksSUFBSUMsT0FBT0MsT0FBT0QsSUFBSSxDQUFDRjtJQUFTLElBQUlHLE9BQU9DLHFCQUFxQixFQUFFO1FBQUUsSUFBSUMsVUFBVUYsT0FBT0MscUJBQXFCLENBQUNKO1FBQVNDLGtCQUFtQkksQ0FBQUEsVUFBVUEsUUFBUUMsTUFBTSxDQUFDLFNBQVVDLEdBQUc7WUFBSSxPQUFPSixPQUFPSyx3QkFBd0IsQ0FBQ1IsUUFBUU8sS0FBS0UsVUFBVTtRQUFFLEVBQUMsR0FBSVAsS0FBS1EsSUFBSSxDQUFDQyxLQUFLLENBQUNULE1BQU1HO0lBQVU7SUFBRSxPQUFPSDtBQUFNO0FBRXBWLFNBQVNVLGNBQWNDLE1BQU07SUFBSSxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUMsVUFBVUMsTUFBTSxFQUFFRixJQUFLO1FBQUUsSUFBSUcsU0FBUyxRQUFRRixTQUFTLENBQUNELEVBQUUsR0FBR0MsU0FBUyxDQUFD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QUFFLEVBQUUsZ0ZBQWdGO1NBQ3RGbEksTUFBTSxDQUFDLFNBQVVpSixDQUFDO1lBQ2pCLE9BQU9iLFdBQVdhLE1BQU1WLE1BQU1VO1FBQ2hDLEdBQUc5RSxJQUFJLENBQUM7SUFDVjtJQUVBLE9BQU9MO0FBQ1Q7QUFDQTs7Ozs7O0NBTUMsR0FFTSxTQUFTb0YsUUFBUUQsQ0FBQztJQUN2QixPQUFPQSxhQUFhRSxnQkFBaUJGLENBQUFBLEVBQUU5RyxJQUFJLEtBQUssZ0JBQWdCOEcsRUFBRTdFLElBQUksS0FBSzZFLEVBQUVHLFNBQVM7QUFDeEY7QUFDQTs7Ozs7O0NBTUMsR0FFTSxTQUFTQyxnQkFBZ0JKLENBQUM7SUFDL0IsT0FBT0EsYUFBYUUsZ0JBQWlCRixDQUFBQSxFQUFFOUcsSUFBSSxLQUFLLG1CQUFtQjhHLEVBQUU3RSxJQUFJLEtBQUs2RSxFQUFFSyxZQUFZO0FBQzlGO0FBQ0E7Ozs7OztDQU1DLEdBRU0sU0FBU2xCLFdBQVdhLENBQUM7SUFDMUIsT0FBT0EsTUFBTSxhQUFhQSxNQUFNLGFBQWFBLE1BQU0sYUFBYUEsTUFBTSxZQUFZQSxNQUFNLG1CQUFtQixpQkFBaUI3RyxJQUFJLENBQUM2RztBQUNuSTtBQUNBOzs7Q0FHQyxHQUVNLFNBQVNWLE1BQU1VLENBQUM7SUFDckIsT0FBTyxjQUFjN0csSUFBSSxDQUFDNkc7QUFDNUIsRUFDQTs7Q0FFQyxJQUVEOzs7O0NBSUMsSUFFRDs7Q0FFQyIsInNvdXJjZXMiOlsid2VicGFjazovL2ltYWdlLWdhbGxlcnkvLi9ub2RlX21vZHVsZXMvcmVhY3QtZHJvcHpvbmUvZGlzdC9lcy91dGlscy9pbmRleC5qcz9mMTEyIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHsgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTsgfVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikgeyBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpdGVyW1N5bWJvbC5pdGVyYXRvcl0gIT0gbnVsbCB8fCBpdGVyW1wiQEBpdGVyYXRvclwiXSAhPSBudWxsKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShhcnIpOyB9XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBlbnVtZXJhYmxlT25seSAmJiAoc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pKSwga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBudWxsICE9IGFyZ3VtZW50c1tpXSA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpICUgMiA/IG93bktleXMoT2JqZWN0KHNvdXJjZSksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpIDogb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9LCBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7IHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7IH1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHsgdmFyIF9pID0gYXJyID09IG51bGwgPyBudWxsIDogdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBhcnJbU3ltYm9sLml0ZXJhdG9yXSB8fCBhcnJbXCJAQGl0ZXJhdG9yXCJdOyBpZiAoX2kgPT0gbnVsbCkgcmV0dXJuOyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9zLCBfZTsgdHJ5IHsgZm9yIChfaSA9IF9pLmNhbGwoYXJyKTsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjsgfVxuXG5pbXBvcnQgX2FjY2VwdHMgZnJvbSBcImF0dHItYWNjZXB0XCI7XG52YXIgYWNjZXB0cyA9IHR5cGVvZiBfYWNjZXB0cyA9PT0gXCJmdW5jdGlvblwiID8gX2FjY2VwdHMgOiBfYWNjZXB0cy5kZWZhdWx0OyAvLyBFcnJvciBjb2Rlc1xuXG5leHBvcnQgdmFyIEZJTEVfSU5WQUxJRF9UWVBFID0gXCJmaWxlLWludmFsaWQtdHlwZVwiO1xuZXhwb3J0IHZhciBGSUxFX1RPT19MQVJHRSA9IFwiZmlsZS10b28tbGFyZ2VcIjtcbmV4cG9ydCB2YXIgRklMRV9UT09fU01BTEwgPSBcImZpbGUtdG9vLXNtYWxsXCI7XG5leHBvcnQgdmFyIFRPT19NQU5ZX0ZJTEVTID0gXCJ0b28tbWFueS1maWxlc1wiO1xuZXhwb3J0IHZhciBFcnJvckNvZGUgPSB7XG4gIEZpbGVJbnZhbGlkVHlwZTogRklMRV9JTlZBTElEX1RZUEUsXG4gIEZpbGVUb29MYXJnZTogRklMRV9UT09fTEFSR0UsXG4gIEZpbGVUb29TbWFsbDogRklMRV9UT09fU01BTEwsXG4gIFRvb01hbnlGaWxlczogVE9PX01BTllfRklMRVNcbn07XG4vKipcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYWNjZXB0XG4gKi9cblxuZXhwb3J0IHZhciBnZXRJbnZhbGlkVHlwZVJlamVjdGlvbkVyciA9IGZ1bmN0aW9uIGdldEludmFsaWRUeXBlUmVqZWN0aW9uRXJyKCkge1xuICB2YXIgYWNjZXB0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBcIlwiO1xuICB2YXIgYWNjZXB0QXJyID0gYWNjZXB0LnNwbGl0KFwiLFwiKTtcbiAgdmFyIG1zZyA9IGFjY2VwdEFyci5sZW5ndGggPiAxID8gXCJvbmUgb2YgXCIuY29uY2F0KGFjY2VwdEFyci5qb2luKFwiLCBcIikpIDogYWNjZXB0QXJyWzBdO1xuICByZXR1cm4ge1xuICAgIGNvZGU6IEZJTEVfSU5WQUxJRF9UWVBFLFxuICAgIG1lc3NhZ2U6IFwiRmlsZSB0eXBlIG11c3QgYmUgXCIuY29uY2F0KG1zZylcbiAgfTtcbn07XG5leHBvcnQgdmFyIGdldFRvb0xhcmdlUmVqZWN0aW9uRXJyID0gZnVuY3Rpb24gZ2V0VG9vTGFyZ2VSZWplY3Rpb25FcnIobWF4U2l6ZSkge1xuICByZXR1cm4ge1xuICAgIGNvZGU6IEZJTEVfVE9PX0xBUkdFLFxuICAgIG1lc3NhZ2U6IFwiRmlsZSBpcyBsYXJnZXIgdGhhbiBcIi5jb25jYXQobWF4U2l6ZSwgXCIgXCIpLmNvbmNhdChtYXhTaXplID09PSAxID8gXCJieXRlXCIgOiBcImJ5dGVzXCIpXG4gIH07XG59O1xuZXhwb3J0IHZhciBnZXRUb29TbWFsbFJlamVjdGlvbkVyciA9IGZ1bmN0aW9uIGdldFRvb1NtYWxsUmVqZWN0aW9uRXJyKG1pblNpemUpIHtcbiAgcmV0dXJuIHtcbiAgICBjb2RlOiBGSUxFX1RPT19TTUFMTCxcbiAgICBtZXNzYWdlOiBcIkZpbGUgaXMgc21hbGxlciB0aGFuIFwiLmNvbmNhdChtaW5TaXplLCBcIiBcIikuY29uY2F0KG1pblNpemUgPT09IDEgPyBcImJ5dGVcIiA6IFwiYnl0ZXNcIilcbiAgfTtcbn07XG5leHBvcnQgdmFyIFRPT19NQU5ZX0ZJTEVTX1JFSkVDVElPTiA9IHtcbiAgY29kZTogVE9PX01BTllfRklMRVMsXG4gIG1lc3NhZ2U6IFwiVG9vIG1hbnkgZmlsZXNcIlxufTtcbi8qKlxuICogQ2hlY2sgaWYgZmlsZSBpcyBhY2NlcHRlZC5cbiAqXG4gKiBGaXJlZm94IHZlcnNpb25zIHByaW9yIHRvIDUzIHJldHVybiBhIGJvZ3VzIE1JTUUgdHlwZSBmb3IgZXZlcnkgZmlsZSBkcmFnLFxuICogc28gZHJhZ292ZXJzIHdpdGggdGhhdCBNSU1FIHR5cGUgd2lsbCBhbHdheXMgYmUgYWNjZXB0ZWQuXG4gKlxuICogQHBhcmFtIHtGaWxlfSBmaWxlXG4gKiBAcGFyYW0ge3N0cmluZ30gYWNjZXB0XG4gKiBAcmV0dXJuc1xuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmaWxlQWNjZXB0ZWQoZmlsZSwgYWNjZXB0KSB7XG4gIHZhciBpc0FjY2VwdGFibGUgPSBmaWxlLnR5cGUgPT09IFwiYXBwbGljYXRpb24veC1tb3otZmlsZVwiIHx8IGFjY2VwdHMoZmlsZSwgYWNjZXB0KTtcbiAgcmV0dXJuIFtpc0FjY2VwdGFibGUsIGlzQWNjZXB0YWJsZSA/IG51bGwgOiBnZXRJbnZhbGlkVHlwZVJlamVjdGlvbkVycihhY2NlcHQpXTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmaWxlTWF0Y2hTaXplKGZpbGUsIG1pblNpemUsIG1heFNpemUpIHtcbiAgaWYgKGlzRGVmaW5lZChmaWxlLnNpemUpKSB7XG4gICAgaWYgKGlzRGVmaW5lZChtaW5TaXplKSAmJiBpc0RlZmluZWQobWF4U2l6ZSkpIHtcbiAgICAgIGlmIChmaWxlLnNpemUgPiBtYXhTaXplKSByZXR1cm4gW2ZhbHNlLCBnZXRUb29MYXJnZVJlamVjdGlvbkVycihtYXhTaXplKV07XG4gICAgICBpZiAoZmlsZS5zaXplIDwgbWluU2l6ZSkgcmV0dXJuIFtmYWxzZSwgZ2V0VG9vU21hbGxSZWplY3Rpb25FcnIobWluU2l6ZSldO1xuICAgIH0gZWxzZSBpZiAoaXNEZWZpbmVkKG1pblNpemUpICYmIGZpbGUuc2l6ZSA8IG1pblNpemUpIHJldHVybiBbZmFsc2UsIGdldFRvb1NtYWxsUmVqZWN0aW9uRXJyKG1pblNpemUpXTtlbHNlIGlmIChpc0RlZmluZWQobWF4U2l6ZSkgJiYgZmlsZS5zaXplID4gbWF4U2l6ZSkgcmV0dXJuIFtmYWxzZSwgZ2V0VG9vTGFyZ2VSZWplY3Rpb25FcnIobWF4U2l6ZSldO1xuICB9XG5cbiAgcmV0dXJuIFt0cnVlLCBudWxsXTtcbn1cblxuZnVuY3Rpb24gaXNEZWZpbmVkKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsO1xufVxuLyoqXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7RmlsZVtdfSBvcHRpb25zLmZpbGVzXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuYWNjZXB0XVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1pblNpemVdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4U2l6ZV1cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubXVsdGlwbGVdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4RmlsZXNdXG4gKiBAcGFyYW0geyhmOiBGaWxlKSA9PiBGaWxlRXJyb3J8RmlsZUVycm9yW118bnVsbH0gW29wdGlvbnMudmFsaWRhdG9yXVxuICogQHJldHVybnNcbiAqL1xuXG5cbmV4cG9ydCBmdW5jdGlvbiBhbGxGaWxlc0FjY2VwdGVkKF9yZWYpIHtcbiAgdmFyIGZpbGVzID0gX3JlZi5maWxlcyxcbiAgICAgIGFjY2VwdCA9IF9yZWYuYWNjZXB0LFxuICAgICAgbWluU2l6ZSA9IF9yZWYubWluU2l6ZSxcbiAgICAgIG1heFNpemUgPSBfcmVmLm1heFNpemUsXG4gICAgICBtdWx0aXBsZSA9IF9yZWYubXVsdGlwbGUsXG4gICAgICBtYXhGaWxlcyA9IF9yZWYubWF4RmlsZXMsXG4gICAgICB2YWxpZGF0b3IgPSBfcmVmLnZhbGlkYXRvcjtcblxuICBpZiAoIW11bHRpcGxlICYmIGZpbGVzLmxlbmd0aCA+IDEgfHwgbXVsdGlwbGUgJiYgbWF4RmlsZXMgPj0gMSAmJiBmaWxlcy5sZW5ndGggPiBtYXhGaWxlcykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBmaWxlcy5ldmVyeShmdW5jdGlvbiAoZmlsZSkge1xuICAgIHZhciBfZmlsZUFjY2VwdGVkID0gZmlsZUFjY2VwdGVkKGZpbGUsIGFjY2VwdCksXG4gICAgICAgIF9maWxlQWNjZXB0ZWQyID0gX3NsaWNlZFRvQXJyYXkoX2ZpbGVBY2NlcHRlZCwgMSksXG4gICAgICAgIGFjY2VwdGVkID0gX2ZpbGVBY2NlcHRlZDJbMF07XG5cbiAgICB2YXIgX2ZpbGVNYXRjaFNpemUgPSBmaWxlTWF0Y2hTaXplKGZpbGUsIG1pblNpemUsIG1heFNpemUpLFxuICAgICAgICBfZmlsZU1hdGNoU2l6ZTIgPSBfc2xpY2VkVG9BcnJheShfZmlsZU1hdGNoU2l6ZSwgMSksXG4gICAgICAgIHNpemVNYXRjaCA9IF9maWxlTWF0Y2hTaXplMlswXTtcblxuICAgIHZhciBjdXN0b21FcnJvcnMgPSB2YWxpZGF0b3IgPyB2YWxpZGF0b3IoZmlsZSkgOiBudWxsO1xuICAgIHJldHVybiBhY2NlcHRlZCAmJiBzaXplTWF0Y2ggJiYgIWN1c3RvbUVycm9ycztcbiAgfSk7XG59IC8vIFJlYWN0J3Mgc3ludGhldGljIGV2ZW50cyBoYXMgZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQsXG4vLyBidXQgdG8gcmVtYWluIGNvbXBhdGliaWxpdHkgd2l0aCBvdGhlciBsaWJzIChQcmVhY3QpIGZhbGwgYmFja1xuLy8gdG8gY2hlY2sgZXZlbnQuY2FuY2VsQnViYmxlXG5cbmV4cG9ydCBmdW5jdGlvbiBpc1Byb3BhZ2F0aW9uU3RvcHBlZChldmVudCkge1xuICBpZiAodHlwZW9mIGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZXZlbnQuY2FuY2VsQnViYmxlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIGV2ZW50LmNhbmNlbEJ1YmJsZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0V2dFdpdGhGaWxlcyhldmVudCkge1xuICBpZiAoIWV2ZW50LmRhdGFUcmFuc2Zlcikge1xuICAgIHJldHVybiAhIWV2ZW50LnRhcmdldCAmJiAhIWV2ZW50LnRhcmdldC5maWxlcztcbiAgfSAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRGF0YVRyYW5zZmVyL3R5cGVzXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9IVE1MX0RyYWdfYW5kX0Ryb3BfQVBJL1JlY29tbWVuZGVkX2RyYWdfdHlwZXMjZmlsZVxuXG5cbiAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zb21lLmNhbGwoZXZlbnQuZGF0YVRyYW5zZmVyLnR5cGVzLCBmdW5jdGlvbiAodHlwZSkge1xuICAgIHJldHVybiB0eXBlID09PSBcIkZpbGVzXCIgfHwgdHlwZSA9PT0gXCJhcHBsaWNhdGlvbi94LW1vei1maWxlXCI7XG4gIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzS2luZEZpbGUoaXRlbSkge1xuICByZXR1cm4gX3R5cGVvZihpdGVtKSA9PT0gXCJvYmplY3RcIiAmJiBpdGVtICE9PSBudWxsICYmIGl0ZW0ua2luZCA9PT0gXCJmaWxlXCI7XG59IC8vIGFsbG93IHRoZSBlbnRpcmUgZG9jdW1lbnQgdG8gYmUgYSBkcmFnIHRhcmdldFxuXG5leHBvcnQgZnVuY3Rpb24gb25Eb2N1bWVudERyYWdPdmVyKGV2ZW50KSB7XG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG59XG5cbmZ1bmN0aW9uIGlzSWUodXNlckFnZW50KSB7XG4gIHJldHVybiB1c2VyQWdlbnQuaW5kZXhPZihcIk1TSUVcIikgIT09IC0xIHx8IHVzZXJBZ2VudC5pbmRleE9mKFwiVHJpZGVudC9cIikgIT09IC0xO1xufVxuXG5mdW5jdGlvbiBpc0VkZ2UodXNlckFnZW50KSB7XG4gIHJldHVybiB1c2VyQWdlbnQuaW5kZXhPZihcIkVkZ2UvXCIpICE9PSAtMTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzSWVPckVkZ2UoKSB7XG4gIHZhciB1c2VyQWdlbnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50O1xuICByZXR1cm4gaXNJZSh1c2VyQWdlbnQpIHx8IGlzRWRnZSh1c2VyQWdlbnQpO1xufVxuLyoqXG4gKiBUaGlzIGlzIGludGVuZGVkIHRvIGJlIHVzZWQgdG8gY29tcG9zZSBldmVudCBoYW5kbGVyc1xuICogVGhleSBhcmUgZXhlY3V0ZWQgaW4gb3JkZXIgdW50aWwgb25lIG9mIHRoZW0gY2FsbHMgYGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKClgLlxuICogTm90ZSB0aGF0IHRoZSBjaGVjayBpcyBkb25lIG9uIHRoZSBmaXJzdCBpbnZva2UgdG9vLFxuICogbWVhbmluZyB0aGF0IGlmIHByb3BhZ2F0aW9uIHdhcyBzdG9wcGVkIGJlZm9yZSBpbnZva2luZyB0aGUgZm5zLFxuICogbm8gaGFuZGxlcnMgd2lsbCBiZSBleGVjdXRlZC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbnMgdGhlIGV2ZW50IGhhbmxkZXIgZnVuY3Rpb25zXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gdGhlIGV2ZW50IGhhbmRsZXIgdG8gYWRkIHRvIGFuIGVsZW1lbnRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY29tcG9zZUV2ZW50SGFuZGxlcnMoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBmbnMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgZm5zW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cblxuICAgIHJldHVybiBmbnMuc29tZShmdW5jdGlvbiAoZm4pIHtcbiAgICAgIGlmICghaXNQcm9wYWdhdGlvblN0b3BwZWQoZXZlbnQpICYmIGZuKSB7XG4gICAgICAgIGZuLmFwcGx5KHZvaWQgMCwgW2V2ZW50XS5jb25jYXQoYXJncykpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaXNQcm9wYWdhdGlvblN0b3BwZWQoZXZlbnQpO1xuICAgIH0pO1xuICB9O1xufVxuLyoqXG4gKiBjYW5Vc2VGaWxlU3lzdGVtQWNjZXNzQVBJIGNoZWNrcyBpZiB0aGUgW0ZpbGUgU3lzdGVtIEFjY2VzcyBBUEldKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9GaWxlX1N5c3RlbV9BY2Nlc3NfQVBJKVxuICogaXMgc3VwcG9ydGVkIGJ5IHRoZSBicm93c2VyLlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNhblVzZUZpbGVTeXN0ZW1BY2Nlc3NBUEkoKSB7XG4gIHJldHVybiBcInNob3dPcGVuRmlsZVBpY2tlclwiIGluIHdpbmRvdztcbn1cbi8qKlxuICogQ29udmVydCB0aGUgYHthY2NlcHR9YCBkcm9wem9uZSBwcm9wIHRvIHRoZVxuICogYHt0eXBlc31gIG9wdGlvbiBmb3IgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL3dpbmRvdy9zaG93T3BlbkZpbGVQaWNrZXJcbiAqXG4gKiBAcGFyYW0ge0FjY2VwdFByb3B9IGFjY2VwdFxuICogQHJldHVybnMge3thY2NlcHQ6IHN0cmluZ1tdfVtdfVxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBwaWNrZXJPcHRpb25zRnJvbUFjY2VwdChhY2NlcHQpIHtcbiAgaWYgKGlzRGVmaW5lZChhY2NlcHQpKSB7XG4gICAgdmFyIGFjY2VwdEZvclBpY2tlciA9IE9iamVjdC5lbnRyaWVzKGFjY2VwdCkuZmlsdGVyKGZ1bmN0aW9uIChfcmVmMikge1xuICAgICAgdmFyIF9yZWYzID0gX3NsaWNlZFRvQXJyYXkoX3JlZjIsIDIpLFxuICAgICAgICAgIG1pbWVUeXBlID0gX3JlZjNbMF0sXG4gICAgICAgICAgZXh0ID0gX3JlZjNbMV07XG5cbiAgICAgIHZhciBvayA9IHRydWU7XG5cbiAgICAgIGlmICghaXNNSU1FVHlwZShtaW1lVHlwZSkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiU2tpcHBlZCBcXFwiXCIuY29uY2F0KG1pbWVUeXBlLCBcIlxcXCIgYmVjYXVzZSBpdCBpcyBub3QgYSB2YWxpZCBNSU1FIHR5cGUuIENoZWNrIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvQmFzaWNzX29mX0hUVFAvTUlNRV90eXBlcy9Db21tb25fdHlwZXMgZm9yIGEgbGlzdCBvZiB2YWxpZCBNSU1FIHR5cGVzLlwiKSk7XG4gICAgICAgIG9rID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShleHQpIHx8ICFleHQuZXZlcnkoaXNFeHQpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIlNraXBwZWQgXFxcIlwiLmNvbmNhdChtaW1lVHlwZSwgXCJcXFwiIGJlY2F1c2UgYW4gaW52YWxpZCBmaWxlIGV4dGVuc2lvbiB3YXMgcHJvdmlkZWQuXCIpKTtcbiAgICAgICAgb2sgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9rO1xuICAgIH0pLnJlZHVjZShmdW5jdGlvbiAoYWdnLCBfcmVmNCkge1xuICAgICAgdmFyIF9yZWY1ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjQsIDIpLFxuICAgICAgICAgIG1pbWVUeXBlID0gX3JlZjVbMF0sXG4gICAgICAgICAgZXh0ID0gX3JlZjVbMV07XG5cbiAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGFnZyksIHt9LCBfZGVmaW5lUHJvcGVydHkoe30sIG1pbWVUeXBlLCBleHQpKTtcbiAgICB9LCB7fSk7XG4gICAgcmV0dXJuIFt7XG4gICAgICAvLyBkZXNjcmlwdGlvbiBpcyByZXF1aXJlZCBkdWUgdG8gaHR0cHM6Ly9jcmJ1Zy5jb20vMTI2NDcwOFxuICAgICAgZGVzY3JpcHRpb246IFwiRmlsZXNcIixcbiAgICAgIGFjY2VwdDogYWNjZXB0Rm9yUGlja2VyXG4gICAgfV07XG4gIH1cblxuICByZXR1cm4gYWNjZXB0O1xufVxuLyoqXG4gKiBDb252ZXJ0IHRoZSBge2FjY2VwdH1gIGRyb3B6b25lIHByb3AgdG8gYW4gYXJyYXkgb2YgTUlNRSB0eXBlcy9leHRlbnNpb25zLlxuICogQHBhcmFtIHtBY2NlcHRQcm9wfSBhY2NlcHRcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGFjY2VwdFByb3BBc0FjY2VwdEF0dHIoYWNjZXB0KSB7XG4gIGlmIChpc0RlZmluZWQoYWNjZXB0KSkge1xuICAgIHJldHVybiBPYmplY3QuZW50cmllcyhhY2NlcHQpLnJlZHVjZShmdW5jdGlvbiAoYSwgX3JlZjYpIHtcbiAgICAgIHZhciBfcmVmNyA9IF9zbGljZWRUb0FycmF5KF9yZWY2LCAyKSxcbiAgICAgICAgICBtaW1lVHlwZSA9IF9yZWY3WzBdLFxuICAgICAgICAgIGV4dCA9IF9yZWY3WzFdO1xuXG4gICAgICByZXR1cm4gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShhKSwgW21pbWVUeXBlXSwgX3RvQ29uc3VtYWJsZUFycmF5KGV4dCkpO1xuICAgIH0sIFtdKSAvLyBTaWxlbnRseSBkaXNjYXJkIGludmFsaWQgZW50cmllcyBhcyBwaWNrZXJPcHRpb25zRnJvbUFjY2VwdCB3YXJucyBhYm91dCB0aGVzZVxuICAgIC5maWx0ZXIoZnVuY3Rpb24gKHYpIHtcbiAgICAgIHJldHVybiBpc01JTUVUeXBlKHYpIHx8IGlzRXh0KHYpO1xuICAgIH0pLmpvaW4oXCIsXCIpO1xuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbi8qKlxuICogQ2hlY2sgaWYgdiBpcyBhbiBleGNlcHRpb24gY2F1c2VkIGJ5IGFib3J0aW5nIGEgcmVxdWVzdCAoZS5nIHdpbmRvdy5zaG93T3BlbkZpbGVQaWNrZXIoKSkuXG4gKlxuICogU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9ET01FeGNlcHRpb24uXG4gKiBAcGFyYW0ge2FueX0gdlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdiBpcyBhbiBhYm9ydCBleGNlcHRpb24uXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQWJvcnQodikge1xuICByZXR1cm4gdiBpbnN0YW5jZW9mIERPTUV4Y2VwdGlvbiAmJiAodi5uYW1lID09PSBcIkFib3J0RXJyb3JcIiB8fCB2LmNvZGUgPT09IHYuQUJPUlRfRVJSKTtcbn1cbi8qKlxuICogQ2hlY2sgaWYgdiBpcyBhIHNlY3VyaXR5IGVycm9yLlxuICpcbiAqIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRE9NRXhjZXB0aW9uLlxuICogQHBhcmFtIHthbnl9IHZcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHYgaXMgYSBzZWN1cml0eSBlcnJvci5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gaXNTZWN1cml0eUVycm9yKHYpIHtcbiAgcmV0dXJuIHYgaW5zdGFuY2VvZiBET01FeGNlcHRpb24gJiYgKHYubmFtZSA9PT0gXCJTZWN1cml0eUVycm9yXCIgfHwgdi5jb2RlID09PSB2LlNFQ1VSSVRZX0VSUik7XG59XG4vKipcbiAqIENoZWNrIGlmIHYgaXMgYSBNSU1FIHR5cGUgc3RyaW5nLlxuICpcbiAqIFNlZSBhY2NlcHRlZCBmb3JtYXQ6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvRWxlbWVudC9pbnB1dC9maWxlI3VuaXF1ZV9maWxlX3R5cGVfc3BlY2lmaWVycy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBpc01JTUVUeXBlKHYpIHtcbiAgcmV0dXJuIHYgPT09IFwiYXVkaW8vKlwiIHx8IHYgPT09IFwidmlkZW8vKlwiIHx8IHYgPT09IFwiaW1hZ2UvKlwiIHx8IHYgPT09IFwidGV4dC8qXCIgfHwgdiA9PT0gXCJhcHBsaWNhdGlvbi8qXCIgfHwgL1xcdytcXC9bLSsuXFx3XSsvZy50ZXN0KHYpO1xufVxuLyoqXG4gKiBDaGVjayBpZiB2IGlzIGEgZmlsZSBleHRlbnNpb24uXG4gKiBAcGFyYW0ge3N0cmluZ30gdlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBpc0V4dCh2KSB7XG4gIHJldHVybiAvXi4qXFwuW1xcd10rJC8udGVzdCh2KTtcbn1cbi8qKlxuICogQHR5cGVkZWYge09iamVjdC48c3RyaW5nLCBzdHJpbmdbXT59IEFjY2VwdFByb3BcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IEZpbGVFcnJvclxuICogQHByb3BlcnR5IHtzdHJpbmd9IG1lc3NhZ2VcbiAqIEBwcm9wZXJ0eSB7RXJyb3JDb2RlfHN0cmluZ30gY29kZVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge1wiZmlsZS1pbnZhbGlkLXR5cGVcInxcImZpbGUtdG9vLWxhcmdlXCJ8XCJmaWxlLXRvby1zbWFsbFwifFwidG9vLW1hbnktZmlsZXNcIn0gRXJyb3JDb2RlXG4gKi8iXSwibmFtZXMiOlsiX3RvQ29uc3VtYWJsZUFycmF5IiwiYXJyIiwiX2FycmF5V2l0aG91dEhvbGVzIiwiX2l0ZXJhYmxlVG9BcnJheSIsIl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSIsIl9ub25JdGVyYWJsZVNwcmVhZCIsIlR5cGVFcnJvciIsIml0ZXIiLCJTeW1ib2wiLCJpdGVyYXRvciIsIkFycmF5IiwiZnJvbSIsImlzQXJyYXkiLCJfYXJyYXlMaWtlVG9BcnJheSIsIm93bktleXMiLCJvYmplY3QiLCJlbnVtZXJhYmxlT25seSIsImtleXMiLCJPYmplY3QiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJzeW1ib2xzIiwiZmlsdGVyIiwic3ltIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsInB1c2giLCJhcHBseSIsIl9vYmplY3RTcHJlYWQiLCJ0YXJnZXQiLCJpIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwic291cmNlIiwiZm9yRWFjaCIsImtleSIsIl9kZWZpbmVQcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiZGVmaW5lUHJvcGVydHkiLCJvYmoiLCJ2YWx1ZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiX3R5cGVvZiIsImNvbnN0cnVjdG9yIiwicHJvdG90eXBlIiwiX3NsaWNlZFRvQXJyYXkiLCJfYXJyYXlXaXRoSG9sZXMiLCJfaXRlcmFibGVUb0FycmF5TGltaXQiLCJfbm9uSXRlcmFibGVSZXN0IiwibyIsIm1pbkxlbiIsIm4iLCJ0b1N0cmluZyIsImNhbGwiLCJzbGljZSIsIm5hbWUiLCJ0ZXN0IiwibGVuIiwiYXJyMiIsIl9pIiwiX2FyciIsIl9uIiwiX2QiLCJfcyIsIl9lIiwibmV4dCIsImRvbmUiLCJlcnIiLCJfYWNjZXB0cyIsImFjY2VwdHMiLCJkZWZhdWx0IiwiRklMRV9JTlZBTElEX1RZUEUiLCJGSUxFX1RPT19MQVJHRSIsIkZJTEVfVE9PX1NNQUxMIiwiVE9PX01BTllfRklMRVMiLCJFcnJvckNvZGUiLCJGaWxlSW52YWxpZFR5cGUiLCJGaWxlVG9vTGFyZ2UiLCJGaWxlVG9vU21hbGwiLCJUb29NYW55RmlsZXMiLCJnZXRJbnZhbGlkVHlwZVJlamVjdGlvbkVyciIsImFjY2VwdCIsInVuZGVmaW5lZCIsImFjY2VwdEFyciIsInNwbGl0IiwibXNnIiwiY29uY2F0Iiwiam9pbiIsImNvZGUiLCJtZXNzYWdlIiwiZ2V0VG9vTGFyZ2VSZWplY3Rpb25FcnIiLCJtYXhTaXplIiwiZ2V0VG9vU21hbGxSZWplY3Rpb25FcnIiLCJtaW5TaXplIiwiVE9PX01BTllfRklMRVNfUkVKRUNUSU9OIiwiZmlsZUFjY2VwdGVkIiwiZmlsZSIsImlzQWNjZXB0YWJsZSIsInR5cGUiLCJmaWxlTWF0Y2hTaXplIiwiaXNEZWZpbmVkIiwic2l6ZSIsImFsbEZpbGVzQWNjZXB0ZWQiLCJfcmVmIiwiZmlsZXMiLCJtdWx0aXBsZSIsIm1heEZpbGVzIiwidmFsaWRhdG9yIiwiZXZlcnkiLCJfZmlsZUFjY2VwdGVkIiwiX2ZpbGVBY2NlcHRlZDIiLCJhY2NlcHRlZCIsIl9maWxlTWF0Y2hTaXplIiwiX2ZpbGVNYXRjaFNpemUyIiwic2l6ZU1hdGNoIiwiY3VzdG9tRXJyb3JzIiwiaXNQcm9wYWdhdGlvblN0b3BwZWQiLCJldmVudCIsImNhbmNlbEJ1YmJsZSIsImlzRXZ0V2l0aEZpbGVzIiwiZGF0YVRyYW5zZmVyIiwic29tZSIsInR5cGVzIiwiaXNLaW5kRmlsZSIsIml0ZW0iLCJraW5kIiwib25Eb2N1bWVudERyYWdPdmVyIiwicHJldmVudERlZmF1bHQiLCJpc0llIiwidXNlckFnZW50IiwiaW5kZXhPZiIsImlzRWRnZSIsImlzSWVPckVkZ2UiLCJ3aW5kb3ciLCJuYXZpZ2F0b3IiLCJjb21wb3NlRXZlbnRIYW5kbGVycyIsIl9sZW4iLCJmbnMiLCJfa2V5IiwiX2xlbjIiLCJhcmdzIiwiX2tleTIiLCJmbiIsImNhblVzZUZpbGVTeXN0ZW1BY2Nlc3NBUEkiLCJwaWNrZXJPcHRpb25zRnJvbUFjY2VwdCIsImFjY2VwdEZvclBpY2tlciIsImVudHJpZXMiLCJfcmVmMiIsIl9yZWYzIiwibWltZVR5cGUiLCJleHQiLCJvayIsImlzTUlNRVR5cGUiLCJjb25zb2xlIiwid2FybiIsImlzRXh0IiwicmVkdWNlIiwiYWdnIiwiX3JlZjQiLCJfcmVmNSIsImRlc2NyaXB0aW9uIiwiYWNjZXB0UHJvcEFzQWNjZXB0QXR0ciIsImEiLCJfcmVmNiIsIl9yZWY3IiwidiIsImlzQWJvcnQiLCJET01FeGNlcHRpb24iLCJBQk9SVF9FUlIiLCJpc1NlY3VyaXR5RXJyb3IiLCJTRUNVUklUWV9FUlIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-dropzone/dist/es/utils/index.js\n");

/***/ })

};
;